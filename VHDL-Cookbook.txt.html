<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>The VHDL Cookbook</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="vhdl">
<meta name="settings" content="no_progress,use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: serif; color: #000000; background-color: #ffffff; }
body { color: #000000; background-color: #ffffff; }
.Comment { font-size: 130%; font-family: monospace; color: #0000c0; }
.bnfOr { font-size: 130%; font-family: monospace; color: #00ff00; }
.Constant { font-size: 130%; font-family: monospace; color: #c00000; }
.Special { font-size: 130%; font-family: monospace; color: #c000c0; }
.Statement { font-size: 130%; font-family: monospace; color: #af5f00; }
.PreProc { font-size: 130%; font-family: monospace; color: #c000c0; }
.Type { font-size: 130%; font-family: monospace; color: #008000; }
.bnfLine { font-size: 130%; font-family: monospace; color: #5fd7ff; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<h1 align=center>The VHDL Cookbook</h1>
<p align=center>Peter J. Ashenden</p>
<h2>1. Introduction</h2>
VHDL is a language for describing digital electronic systems. It arose out of the United States Government’s Very High Speed Integrated Circuits (VHSIC) program, initiated in 1980. In the course of this program, it became clear that there was a need for a standard language for describing the structure and function of integrated circuits (ICs). Hence the VHSIC Hardware Description Language (VHDL) was developed, and subsequently adopted as a standard by the Institute of Electrical and Electronic Engineers (IEEE) in the US.
VHDL is designed to fill a number of needs in the design process.  Firstly, it allows description of the structure of a design, that is how it is decomposed into sub-designs, and how those sub-designs are interconnected. Secondly, it allows the specification of the function of designs using familiar programming language forms. Thirdly, as a result, it allows a design to be simulated before being manufactured, so that designers can quickly compare alternatives and test for correctness without the delay and expense of hardware prototyping.
The purpose of this booklet is to give you a quick introduction to VHDL.  This is done by informally describing the facilities provided by the language, and using examples to illustrate them. This booklet does not fully describe every aspect of the language. For such fine details, you should consult the IEEE Standard VHDL Language Reference Manual.  However, be warned: the standard is like a legal document, and is very difficult to read unless you are already familiar with the language. This booklet does cover enough of the language for substantial model writing. It assumes you know how to write computer programs using a conventional programming language such as Pascal, C or Ada.
The remaining chapters of this booklet describe the various aspects of VHDL in a bottom-up manner. Chapter2 describes the facilities of VHDL which most resemble normal sequential programming languages. These include data types, variables, expressions, sequential statements and subprograms. Chapter3 then examines the facilities for describing the structure of a module and how it it decomposed into sub-modules.  Chapter4 covers aspects of VHDL that integrate the programming language features with a discrete event timing model to allow simulation of behaviour. Chapter5 is a key chapter that shows how all these facilities are combined to form a complete model of a system. Then Chapter6 is a potpourri of more advanced features which you may find useful for modelling more complex systems.
Throughout this booklet, the syntax of language features is presented in Backus-Naur Form (BNF). The syntax specifications are drawn from the IEEE VHDL Standard. Concrete examples are also given to illustrate the language features. In some cases, some alternatives are omitted from BNF productions where they are not directly relevant to the context. For this reason, the full syntax is included in AppendixA, and should be consulted as a reference.

<h3>1.1. Describing Structure</h3>
A digital electronic system can be described as a module with inputs and/or outputs. The electrical values on the outputs are some function of the values on the inputs. Figure1-1(a) shows an example of this view of a digital system. The module F has two inputs, A and B, and an output Y.  Using VHDL terminology, we call the module F a design entity, and the inputs and outputs are called ports.
One way of describing the function of a module is to describe how it is composed of sub-modules. Each of the sub-modules is an instance of some entity, and the ports of the instances are connected using signals.  Figure1-1(b) shows how the entity F might be composed of instances of entities G, H and I. This kind of description is called a structural description. Note that each of the entities G, H and I might also have a structural description.

<h3>1.2. Describing Behaviour</h3>
In many cases, it is not appropriate to describe a module structurally.  One such case is a module which is at the bottom of the hierarchy of some other structural description. For example, if you are designing a system using IC packages bought from an IC shop, you do not need to describe the internal structure of an IC. In such cases, a description of the function performed by the module is required, without reference to its actual internal structure. Such a description is called a functional or behavioural description.
To illustrate this, suppose that the function of the entity F in Figure1-1(a) is the exclusive-or function. Then a behavioural description of F could be the Boolean function

    Y <span class="Statement">=</span> A <span class="Special">.</span> B <span class="Statement">+</span> A <span class="Special">.</span> B


More complex behaviours cannot be described purely as a function of inputs. In systems with feedback, the outputs are also a function of time.  VHDL solves this problem by allowing description of behaviour in the form of an executable program. Chapters2 and4 describe the programming language facilities.

<h3>1.3. Discrete Event Time Model</h3>
Once the structure and behaviour of a module have been specified, it is possible to simulate the module by executing its behavioural description. This is done by simulating the passage of time in discrete steps. At some simulation time, a module input may be stimulated by changing the value on an input port. The module reacts by running the code of its behavioural description and scheduling new values to be placed on the signals connected to its output ports at some later simulated time. This is called scheduling a transaction on that signal. If the new value is different from the previous value on the signal, an event occurs, and other modules with input ports connected to the signal may be activated.
The simulation starts with an initialisation phase, and then proceeds by repeating a two-stage simulation cycle. In the initialisation phase, all signals are given initial values, the simulation time is set to zero, and each module’s behaviour program is executed. This usually results in transactions being scheduled on output signals for some later time.
In the first stage of a simulation cycle, the simulated time is advanced to the earliest time at which a transaction has been scheduled. All transactions scheduled for that time are executed, and this may cause events to occur on some signals.
In the second stage, all modules which react to events occurring in the first stage have their behaviour program executed. These programs will usually schedule further transactions on their output signals. When all of the behaviour programs have finished executing, the simulation cycle repeats. If there are no more scheduled transactions, the whole simulation is completed.
The purpose of the simulation is to gather information about the changes in system state over time. This can be done by running the simulation under the control of a simulation monitor. The monitor allows signals and other state information to be viewed or stored in a trace file for later analysis. It may also allow interactive stepping of the simulation process, much like an interactive program debugger.

<h3>1.4. A Quick Example</h3>
In this section we will look at a small example of a VHDL description of a two-bit counter to give you a feel for the language and how it is used. We start the description of an entity by specifying its external interface, which includes a description of its ports. So the counter might be defined as:

    <span class="Statement">entity</span> count2 <span class="Statement">is</span>
        <span class="Statement">generic</span> <span class="Special">(</span>prop_delay : <span class="Type">Time</span> <span class="Statement">:=</span> <span class="Constant">10 ns</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>clock : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span> q1<span class="Special">,</span> q0 : <span class="Statement">out</span> <span class="Type">bit</span><span class="Special">);</span>
    <span class="Statement">end</span> count2<span class="Special">;</span>


This specifies that the entity count2 has one input and two outputs, all of which are bit values, that is, they can take on the values '0' or '1'. It also defines a generic constant called prop_delay which can be used to control the operation of the entity (in this case its propagation delay). If no value is explicitly given for this value when the entity is used in a design, the default value of 10ns will be used.
An implementation of the entity is described in an architecture body.  There may be more than one architecture body corresponding to a single entity specification, each of which describes a different view of the entity.  For example, a behavioural description of the counter could be written as:

    <span class="Statement">architecture</span> behaviour <span class="Statement">of</span> count2 <span class="Statement">is</span>
    <span class="Statement">begin</span>
        count_up: <span class="Statement">process</span> <span class="Special">(</span>clock<span class="Special">)</span>
            <span class="Statement">variable</span> count_value : <span class="Type">natural</span> <span class="Statement">:=</span> <span class="Constant">0</span><span class="Special">;</span>
        <span class="Statement">begin</span>
            <span class="Statement">if</span> clock <span class="Statement">=</span> <span class="Constant">'1'</span> <span class="Statement">then</span>
                count_value <span class="Statement">:=</span> <span class="Special">(</span>count_value <span class="Statement">+</span> <span class="Constant">1</span><span class="Special">)</span> <span class="Statement">mod</span> <span class="Constant">4</span><span class="Special">;</span>
                q0 <span class="Statement">&lt;=</span> <span class="Type">bit'</span>val<span class="Special">(</span>count_value <span class="Statement">mod</span> <span class="Constant">2</span><span class="Special">)</span> <span class="Statement">after</span> prop_delay<span class="Special">;</span>
                q1 <span class="Statement">&lt;=</span> <span class="Type">bit'</span>val<span class="Special">(</span>count_value <span class="Statement">/</span> <span class="Constant">2</span><span class="Special">)</span> <span class="Statement">after</span> prop_delay<span class="Special">;</span>
            <span class="Statement">end</span> <span class="Statement">if</span> <span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">process</span> count_up<span class="Special">;</span>
    <span class="Statement">end</span> behaviour<span class="Special">;</span>


In this description of the counter, the behaviour is implemented by a process called count_up, which is sensitive to the input clock. A process is a body of code which is executed whenever any of the signals it is sensitive to changes value. This process has a variable called count_value to store the current state of the counter. The variable is initialised to zero at the start of simulation, and retains its value between activations of the process. When the clock input changes from '0' to '1', the state variable is incremented, and transactions are scheduled on the two output ports based on the new value.  The assignments use the generic constant prop_delay to determine how long after the clock change the transaction should be scheduled. When control reaches the end of the process body, the process is suspended until another change occurs on clock.
The two-bit counter might also be described as a circuit composed of two T-flip-flops and an inverter, as shown in Figure1-2. This can be written in VHDL as:

    <span class="Statement">architecture</span> structure <span class="Statement">of</span> count2 <span class="Statement">is</span>
        <span class="Statement">component</span> t_flipflop
            <span class="Statement">port</span> <span class="Special">(</span>
                ck : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
                q : <span class="Statement">out</span> <span class="Type">bit</span>
            <span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">component</span> <span class="Special">;</span>
        <span class="Statement">component</span> inverter
            <span class="Statement">port</span> <span class="Special">(</span>
                a : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
                y : <span class="Statement">out</span> <span class="Type">bit</span>
            <span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">component</span> <span class="Special">;</span>
        <span class="Statement">signal</span> ff0<span class="Special">,</span> ff1<span class="Special">,</span> inv_ff0 : <span class="Type">bit</span><span class="Special">;</span>
    <span class="Statement">begin</span>
        bit_0 : t_flipflop <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>ck <span class="Statement">=&gt;</span> clock<span class="Special">,</span> q <span class="Statement">=&gt;</span> ff0<span class="Special">);</span>
        inv : inverter <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>a <span class="Statement">=&gt;</span> ff0<span class="Special">,</span> y <span class="Statement">=&gt;</span> inv_ff0<span class="Special">);</span>
        bit_1 : t_flipflop <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>ck <span class="Statement">=&gt;</span> inv_ff0<span class="Special">,</span> q <span class="Statement">=&gt;</span> ff1<span class="Special">);</span>
        q0 <span class="Statement">&lt;=</span> ff0<span class="Special">;</span>
        q1 <span class="Statement">&lt;=</span> ff1<span class="Special">;</span>
    <span class="Statement">end</span> structure<span class="Special">;</span>


In this architecture, two component types are declared, t_flipflop and inverter, and three internal signals are declared. Each of the components is then instantiated, and the ports of the instances are mapped onto signals and ports of the entity. For example, bit_0 is an instance of the t_flipflop component, with its ck port connected to the clock port of the count2 entity, and its q port connected to the internal signal ff0. The last two signal assignments update the entity ports whenever the values on the internal signals change.

<h2>2. VHDL is Like a Programming Language</h2>
As mentioned in Section 1.2, the behaviour of a module may be described in programming language form. This chapter describes the facilities in VHDL which are drawn from the familiar programming language repertoire. If you are familiar with the Ada programming language, you will notice the similarity with that language. This is both a convenience and a nuisance. The convenience is that you don’t have much to learn to use these VHDL facilities. The problem is that the facilities are not as comprehensive as those of Ada, though they are certainly adequate for most modelling purposes.

<h3>2.1. Lexical Elements</h3>

<h4>2.1.0. Fundamental elements</h4>

<span class="Constant">upper_case_letter </span><span class="PreProc">::=</span>
<span class="bnfLine">    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï D. Ñ Ò Ó Ô Õ Ö Ø Ù Ú Û Ü Ý P'</span>

<span class="Constant">digit </span><span class="PreProc">::=</span>
<span class="bnfLine">    0 1 2 3 4 5 6 7 8 9</span>

<span class="Constant">special_character </span><span class="PreProc">::=</span>
<span class="bnfLine">    &quot; # &amp; ' ( ) * + , - . / : ; &lt; = &gt; [ ] _ |</span>

<span class="Constant">space_character </span><span class="PreProc">::=</span>
<span class="bnfLine">    SPACE NBSP</span>

<span class="Constant">lower_case_letter </span><span class="PreProc">::=</span>
<span class="bnfLine">    a b c d e f g h i j k l m n o p q r s t u v w x y z ß à á â ã ä å æ ç è é ê ë ì í î ï ∂´ ñ ò ó ô õ ö ø ù ú û ü ý p' ÿ</span>

<span class="Constant">other_special_character </span><span class="PreProc">::=</span>
<span class="bnfLine">    ! $ % @ ? \ ^ ` { } ~ ¡ ¢ £ € ¥ | §  ̈ © a « ¬ -®  ̄ ° ± 2 3  ́ μ ¶ •  ̧ 1 o » 1/4 1/2 3/4 ¿ ◊ ÷ - (soft hyphen)</span>

<span class="Constant">basic_graphic_character </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">upper_case_letter</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">digit</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">special_character</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">space_character</span>

<span class="Constant">graphic_character </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">basic_graphic_character</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">lower_case_letter</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">other_special_character</span>

<span class="Constant">basic_character </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">basic_graphic_character</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">format_effector</span>

<span class="Constant">format_effectors </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="Comment">-- The ISO (and ASCII) characters called horizontal tabulation, vertical tabulation, carriage return, line feed, and form feed.</span>


<h4>2.1.1. Comments</h4>
Comments in VHDL start with two adjacent hyphens (‘--’) and extend to the end of the line. They have no part in the meaning of a VHDL description.

<h4>2.1.2. Identifiers</h4>
Identifiers in VHDL are used as reserved words and as programmer defined names. They must conform to the rule:

<span class="Constant">identifier </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">basic_identifier</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">extended_identifier</span>

<span class="Constant">basic_identifier </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">letter</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> _ </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">letter_or_digit</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">letter_or_digit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">letter</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">digit</span>

<span class="Constant">letter </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">upper_case_letter</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">lower_case_letter</span>

<span class="Constant">extended_identifier </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">\</span><span class="Statement"> </span><span class="bnfLine">graphic_character</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">graphic_character</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfLine">\</span>


Note that case of letters is not considered significant, so the identifiers cat and Cat are the same. Underline characters in identifiers are significant, so This_Name and ThisName are different identifiers.

<h4>2.1.3. Numbers</h4>
Literal numbers may be expressed either in decimal or in a base between two and sixteen. If the literal includes a point, it represents a real number, otherwise it represents an integer. Decimal literals are defined by:

<span class="Constant">abstract_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">decimal_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">based_literal</span>

<span class="Constant">decimal_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">integer</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> . </span><span class="bnfLine">integer</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">exponent</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">integer </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">digit</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> _ </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">digit</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">exponent </span><span class="PreProc">::=</span>
<span class="Statement">    E </span><span class="bnfOr">[</span><span class="Statement"> + </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">integer</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    E - </span><span class="bnfLine">integer</span>


Some examples are:

    <span class="Constant">0</span> <span class="Constant">1</span> <span class="Constant">123_456_789</span> <span class="Constant">987E6</span><span class="Comment"> -- integer literals</span>
    <span class="Constant">0.0</span> <span class="Constant">0.5</span> <span class="Constant">2.718_28</span> <span class="Constant">12.4E-9</span><span class="Comment"> -- real literals</span>


Based literal numbers are defined by:

<span class="Constant">based_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">base</span><span class="Statement"> # </span><span class="bnfLine">based_integer</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> . </span><span class="bnfLine">based_integer</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> # </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">exponent</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">base </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">integer</span>

<span class="Constant">based_integer </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">extended_digit</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> _ </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">extended_digit</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">extended_digit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">digit</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">letter</span>


The base and the exponent are expressed in decimal. The exponent indicates the power of the base by which the literal is multiplied. The letters A to F (upper or lower case) are used as extended digits to represent 10 to 15. Some examples:

    <span class="Constant">2#1100_0100#</span> <span class="Constant">16#C4#</span> <span class="Constant">2#1.1111_1111_111#E+11</span> <span class="Constant">4#301#E1</span><span class="Comment"> -- the integer 196</span>
    <span class="Constant">16#F.FF#E2</span><span class="Comment"> -- the real number 4095.0</span>


<h4>2.1.4. Characters</h4>
Literal characters are formed by enclosing an ASCII character in single-quote marks. For example:

<span class="Constant">character_literal </span><span class="PreProc">::=</span>
<span class="Statement">    ' </span><span class="bnfLine">graphic_character</span><span class="Statement"> '</span>



    <span class="Constant">'A'</span> <span class="Constant">'*'</span> <span class="Constant">'''</span> <span class="Constant">' '</span>


<h4>2.1.5. Strings</h4>
Literal strings of characters are formed by enclosing the characters in double-quote marks. To include a double-quote mark itself in a string, a pair of double-quote marks must be put together. A string can be used as a value for an object which is an array of characters. Examples of strings:

<span class="Constant">string_literal </span><span class="PreProc">::=</span>
<span class="Statement">    &quot; </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">graphic_character</span><span class="Statement"> </span><span class="bnfOr">|</span><span class="Statement"> &quot;&quot; </span><span class="bnfOr">}</span><span class="Statement"> &quot;</span>



    <span class="Constant">&quot;A string&quot;</span> <span class="Constant">&quot;&quot;</span><span class="Comment"> -- empty string</span>
    <span class="Constant">&quot;A string in a string: &quot;&quot;A string&quot;&quot;. &quot;</span><span class="Comment"> -- contains quote marks</span>


<h4>2.1.6. Bit Strings</h4>
VHDL provides a convenient way of specifying literal values for arrays of type bit ('0's and '1's, see Section 2.2.5). The syntax is:

<span class="Constant">bit_string_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">base_specifier</span><span class="Statement"> &quot; </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">bit_value</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> &quot;</span>

<span class="Constant">base_specifier </span><span class="PreProc">::=</span>
<span class="Statement">    B </span><span class="bnfOr">|</span><span class="Statement"> O </span><span class="bnfOr">|</span><span class="Statement"> X</span>

<span class="Constant">bit_value </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">extended_digit</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> _ </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">extended_digit</span><span class="Statement"> </span><span class="bnfOr">}</span>


Base specifier B stands for binary, O for octal and X for hexadecimal. Some examples:

    <span class="Constant">B&quot;1010110&quot;</span><span class="Comment"> -- length is 7</span>
    <span class="Constant">O&quot;126&quot;</span><span class="Comment"> -- length is 9, equivalent to B&quot;001_010_110&quot;</span>
    <span class="Constant">X&quot;56&quot;</span><span class="Comment"> -- length is 8, equivalent to B&quot;0101_0110&quot;</span>


<h4>2.1.7. Allowable replacements of characters</h4>
The following replacements are allowed for the vertical line, number sign, and quotation mark basic characters:
     — A vertical line (|) can be replaced by an exclamation mark (!) where used as a delimiter.
     — The number sign (#) of a based literal can be replaced by colons (:), provided that the replacement is done for both occurrences.
     — The quotation marks (&quot;) used as string brackets at both ends of a string literal can be replaced by percent signs (%), provided that the enclosed sequence of characters contains no quotation marks, and provided that both string brackets are replaced. Any percent sign within the sequence of characters must then be doubled, and each such doubled percent sign is interpreted as a single percent sign value. The same replacement is allowed for a bit string literal, provided that both bit string brackets are replaced.

<h3>2.2. Data Types and Objects</h3>
VHDL provides a number of basic, or scalar, types, and a means of forming composite types. The scalar types include numbers, physical quantities, and enumerations (including enumerations of characters), and there are a number of standard predefined basic types. The composite types provided are arrays and records. VHDL also provides access types (pointers) and files, although these will not be fully described in this booklet.
A data type can be defined by a type declaration:

<span class="Constant">full_type_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    type </span><span class="bnfLine">identifier</span><span class="Statement"> is </span><span class="bnfLine">type_definition</span><span class="Statement"> ;</span>

<span class="Constant">type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">scalar_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">composite_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">access_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">protected_type_definition</span>

<span class="Constant">scalar_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">enumeration_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">integer_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">floating_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">physical_type_definition</span>

<span class="Constant">composite_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">array_type_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">record_type_definition</span>


Examples of different kinds of type declarations are given in the following sections.

<h4>2.2.1. Integer Types</h4>
An integer type is a range of integer values within a specified range.  The syntax for specifying integer types is:

<span class="Constant">integer_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">range_constraint</span>

<span class="Constant">range_constraint </span><span class="PreProc">::=</span>
<span class="Statement">    range </span><span class="bnfLine">range_term</span>

<span class="Constant">range_term </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>range</i>_attribute_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">simple_expression</span><span class="Statement"> </span><span class="bnfLine">direction</span><span class="Statement"> </span><span class="bnfLine">simple_expression</span>

<span class="Constant">direction </span><span class="PreProc">::=</span>
<span class="Statement">    to </span><span class="bnfOr">|</span><span class="Statement"> downto</span>


The expressions that specify the range must of course evaluate to integer numbers. Types declared with the keyword to are called ascending ranges, and those declared with the keyword downto are called descending ranges.  The VHDL standard allows an implementation to restrict the range, but requires that it must at least allow the range –2147483647 to +2147483647.
Some examples of integer type declarations:

    <span class="Statement">type</span> byte_int <span class="Statement">is</span> <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">255</span><span class="Special">;</span>
    <span class="Statement">type</span> signed_word_int <span class="Statement">is</span> <span class="Statement">range</span> –<span class="Constant">32768</span> <span class="Statement">to</span> <span class="Constant">32767</span><span class="Special">;</span>
    <span class="Statement">type</span> bit_index <span class="Statement">is</span> <span class="Statement">range</span> <span class="Constant">31</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">;</span>


There is a predefined integer type called integer. The range of this type is implementation defined, though it is guaranteed to include –2147483647 to +2147483647.

<h4>2.2.2. Physical Types</h4>
A physical type is a numeric type for representing some physical quantity, such as mass, length, time or voltage. The declaration of a physical type includes the specification of a base unit, and possibly a number of secondary units, being multiples of the base unit. The syntax for declaring physical types is:

<span class="Constant">physical_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">range_constraint</span>
<span class="Statement">        units </span><span class="bnfLine">base_unit_declaration</span>
<span class="Statement">        </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">secondary_unit_declaration</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">    end units </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">physical_type_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">base_unit_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> ;</span>

<span class="Constant">secondary_unit_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> = </span><span class="bnfLine">physical_literal</span><span class="Statement"> ;</span>

<span class="Constant">physical_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">abstract_literal</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine"><i>unit</i>_name</span>


Some examples of physical type declarations:

    <span class="Statement">type</span> length <span class="Statement">is</span> <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">1E9</span>
        <span class="Statement">units</span> um<span class="Special">;</span>
        mm <span class="Statement">=</span> <span class="Constant">1000</span> um<span class="Special">;</span>
        cm <span class="Statement">=</span> <span class="Constant">10</span> mm<span class="Special">;</span>
        m <span class="Statement">=</span> <span class="Constant">1000</span> mm<span class="Special">;</span>
        <span class="Statement">in</span> <span class="Statement">=</span> <span class="Constant">25.4</span> mm<span class="Special">;</span>
        ft <span class="Statement">=</span> <span class="Constant">12</span> <span class="Statement">in</span><span class="Special">;</span>
        yd <span class="Statement">=</span> <span class="Constant">3</span> ft<span class="Special">;</span>
        rod <span class="Statement">=</span> <span class="Constant">198</span> <span class="Statement">in</span><span class="Special">;</span>
        chain <span class="Statement">=</span> <span class="Constant">22</span> yd<span class="Special">;</span>
        furlong <span class="Statement">=</span> <span class="Constant">10</span> chain<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">units</span><span class="Special">;</span>

    <span class="Statement">type</span> resistance <span class="Statement">is</span> <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">1E8</span>
        <span class="Statement">units</span> ohms<span class="Special">;</span>
        kohms <span class="Statement">=</span> <span class="Constant">1000</span> ohms<span class="Special">;</span>
        Mohms <span class="Statement">=</span> <span class="Constant">1E6</span> ohms<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">units</span><span class="Special">;</span>


The predefined physical type time is important in VHDL, as it is used extensively to specify delays in simulations. Its definition is:

    <span class="Statement">type</span> <span class="Type">time</span> <span class="Statement">is</span>  <span class="Statement">range</span> implementation_defined
        <span class="Statement">units</span>
            fs<span class="Special">;</span>
            ps <span class="Statement">=</span> <span class="Constant">1000 fs</span><span class="Special">;</span>
            ns <span class="Statement">=</span> <span class="Constant">1000 ps</span><span class="Special">;</span>
            us <span class="Statement">=</span> <span class="Constant">1000 ns</span><span class="Special">;</span>
            ms <span class="Statement">=</span> <span class="Constant">1000 us</span><span class="Special">;</span>
            sec <span class="Statement">=</span> <span class="Constant">1000 ms</span><span class="Special">;</span>
            min <span class="Statement">=</span> <span class="Constant">60 sec</span><span class="Special">;</span>
            hr <span class="Statement">=</span> <span class="Constant">60 min</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">units</span> <span class="Special">;</span>


To write a value of some physical type, you write the number followed by the unit. For example:

    <span class="Constant">10</span> mm <span class="Constant">1</span> rod <span class="Constant">1200</span> ohm <span class="Constant">23 ns</span>


<h4>2.2.3. Floating Point Types</h4>
A floating point type is a discrete approximation to the set of real numbers in a specified range. The precision of the approximation is not defined by the VHDL language standard, but must be at least six decimal digits. The range must include at least –1E38 to +1E38. A floating point type is declared using the syntax:

<span class="Constant">floating_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">range_constraint</span>


Some examples are:

    <span class="Statement">type</span> signal_level <span class="Statement">is</span> <span class="Statement">range</span> –<span class="Constant">10.00</span> <span class="Statement">to</span> <span class="Statement">+</span><span class="Constant">10.00</span><span class="Special">;</span>
    <span class="Statement">type</span> probability <span class="Statement">is</span> <span class="Statement">range</span> <span class="Constant">0.0</span> <span class="Statement">to</span> <span class="Constant">1.0</span><span class="Special">;</span>


There is a predefined floating point type called real. The range of this type is implementation defined, though it is guaranteed to include –1E38 to +1E38.

<h4>2.2.4. Enumeration Types</h4>
An enumeration type is an ordered set of identifiers or characters. The identifiers and characters within a single enumeration type must be distinct, however they may be reused in several different enumeration types.
The syntax for declaring an enumeration type is:

<span class="Constant">enumeration_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    ( </span><span class="bnfLine">enumeration_literal</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">enumeration_literal</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement">  )</span>

<span class="Constant">enumeration_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">character_literal</span>


Some examples are:

    <span class="Statement">type</span> logic_level <span class="Statement">is</span> <span class="Special">(</span>unknown<span class="Special">,</span> low<span class="Special">,</span> undriven<span class="Special">,</span> high<span class="Special">);</span>
    <span class="Statement">type</span> alu_function <span class="Statement">is</span> <span class="Special">(</span>disable<span class="Special">,</span> pass<span class="Special">,</span> add<span class="Special">,</span> subtract<span class="Special">,</span> multiply<span class="Special">,</span> divide<span class="Special">);</span>
    <span class="Statement">type</span> octal_digit <span class="Statement">is</span> <span class="Special">(</span><span class="Constant">'0'</span><span class="Special">,</span> <span class="Constant">'1'</span><span class="Special">,</span> <span class="Constant">'2'</span><span class="Special">,</span> <span class="Constant">'3'</span><span class="Special">,</span> <span class="Constant">'4'</span><span class="Special">,</span> <span class="Constant">'5'</span><span class="Special">,</span> <span class="Constant">'6'</span><span class="Special">,</span> <span class="Constant">'7'</span><span class="Special">);</span>


There are a number of predefined enumeration types, defined as follows:

    <span class="Statement">type</span> severity_level <span class="Statement">is</span> <span class="Special">(</span><span class="Statement">note</span><span class="Special">,</span> <span class="Statement">warning</span><span class="Special">,</span> <span class="Statement">error</span><span class="Special">,</span> <span class="Statement">failure</span><span class="Special">);</span>
    <span class="Statement">type</span> <span class="Type">boolean</span> <span class="Statement">is</span> <span class="Special">(</span><span class="Constant">false</span><span class="Special">,</span> <span class="Constant">true</span><span class="Special">);</span>
    <span class="Statement">type</span> <span class="Type">bit</span> <span class="Statement">is</span> <span class="Special">(</span><span class="Constant">'0'</span><span class="Special">,</span> <span class="Constant">'1'</span><span class="Special">);</span>
    <span class="Statement">type</span> <span class="Type">character</span> <span class="Statement">is</span> <span class="Special">(</span> NUL<span class="Special">,</span> SOH<span class="Special">,</span> BS<span class="Special">,</span> HT<span class="Special">,</span> DLE<span class="Special">,</span> DC1<span class="Special">,</span> CAN<span class="Special">,</span> EM<span class="Special">,</span> <span class="Constant">' '</span><span class="Special">,</span> <span class="Constant">'!'</span><span class="Special">,</span> <span class="Constant">'('</span><span class="Special">,</span> <span class="Constant">')'</span><span class="Special">,</span> <span class="Constant">'0'</span><span class="Special">,</span> <span class="Constant">'1'</span><span class="Special">,</span> <span class="Constant">'8'</span><span class="Special">,</span> <span class="Constant">'9'</span><span class="Special">,</span> <span class="Constant">'@'</span><span class="Special">,</span> <span class="Constant">'A'</span><span class="Special">,</span> <span class="Constant">'H'</span><span class="Special">,</span> <span class="Constant">'I'</span><span class="Special">,</span> <span class="Constant">'P'</span><span class="Special">,</span> <span class="Constant">'Q'</span><span class="Special">,</span> <span class="Constant">'X'</span><span class="Special">,</span> <span class="Constant">'Y'</span><span class="Special">,</span> <span class="Constant">'`'</span><span class="Special">,</span> <span class="Constant">'a'</span><span class="Special">,</span> <span class="Constant">'h'</span><span class="Special">,</span> <span class="Constant">'i'</span><span class="Special">,</span> <span class="Constant">'p'</span><span class="Special">,</span> <span class="Constant">'q'</span><span class="Special">,</span> <span class="Constant">'x'</span><span class="Special">,</span> <span class="Constant">'y'</span><span class="Special">,</span> STX<span class="Special">,</span> LF<span class="Special">,</span> DC2<span class="Special">,</span> SUB<span class="Special">,</span> <span class="Constant">'&quot;'</span><span class="Special">,</span> <span class="Constant">'*'</span><span class="Special">,</span> <span class="Constant">'2'</span><span class="Special">,</span> <span class="Constant">':'</span><span class="Special">,</span> <span class="Constant">'B'</span><span class="Special">,</span> <span class="Constant">'J'</span><span class="Special">,</span> <span class="Constant">'R'</span><span class="Special">,</span> <span class="Constant">'Z'</span><span class="Special">,</span> <span class="Constant">'b'</span><span class="Special">,</span> <span class="Constant">'j'</span><span class="Special">,</span> <span class="Constant">'r'</span><span class="Special">,</span> <span class="Constant">'z'</span><span class="Special">,</span> ETX<span class="Special">,</span> VT<span class="Special">,</span> DC3<span class="Special">,</span> ESC<span class="Special">,</span> <span class="Constant">'#'</span><span class="Special">,</span> <span class="Constant">'+'</span><span class="Special">,</span> <span class="Constant">'3'</span><span class="Special">,</span> <span class="Constant">';'</span><span class="Special">,</span> <span class="Constant">'C'</span><span class="Special">,</span> <span class="Constant">'K'</span><span class="Special">,</span> <span class="Constant">'S'</span><span class="Special">,</span> <span class="Constant">'['</span><span class="Special">,</span> <span class="Constant">'c'</span><span class="Special">,</span> <span class="Constant">'k'</span><span class="Special">,</span> <span class="Constant">'s'</span><span class="Special">,</span> <span class="Constant">'{'</span><span class="Special">,</span> EOT<span class="Special">,</span> FF<span class="Special">,</span> DC4<span class="Special">,</span> FSP<span class="Special">,</span> <span class="Constant">'$'</span><span class="Special">,</span> <span class="Constant">','</span><span class="Special">,</span> <span class="Constant">'4'</span><span class="Special">,</span> <span class="Constant">'&lt;'</span><span class="Special">,</span> <span class="Constant">'D'</span><span class="Special">,</span> <span class="Constant">'L'</span><span class="Special">,</span> <span class="Constant">'T'</span><span class="Special">,</span> <span class="Constant">'\'</span><span class="Special">,</span> <span class="Constant">'d'</span><span class="Special">,</span> <span class="Constant">'l'</span><span class="Special">,</span> <span class="Constant">'t'</span><span class="Special">,</span> <span class="Constant">'|'</span><span class="Special">,</span> ENQ<span class="Special">,</span> CR<span class="Special">,</span> NAK<span class="Special">,</span> GSP<span class="Special">,</span> <span class="Constant">'%'</span><span class="Special">,</span> <span class="Constant">'-'</span><span class="Special">,</span> <span class="Constant">'5'</span><span class="Special">,</span> <span class="Constant">'='</span><span class="Special">,</span> <span class="Constant">'E'</span><span class="Special">,</span> <span class="Constant">'M'</span><span class="Special">,</span> <span class="Constant">'U'</span><span class="Special">,</span> <span class="Constant">']'</span><span class="Special">,</span> <span class="Constant">'e'</span><span class="Special">,</span> <span class="Constant">'m'</span><span class="Special">,</span> <span class="Constant">'u'</span><span class="Special">,</span> <span class="Constant">'}'</span><span class="Special">,</span> ACK<span class="Special">,</span> SO<span class="Special">,</span> SYN<span class="Special">,</span> RSP<span class="Special">,</span> <span class="Constant">'&amp;'</span><span class="Special">,</span> <span class="Constant">'.'</span><span class="Special">,</span> <span class="Constant">'6'</span><span class="Special">,</span> <span class="Constant">'&gt;'</span><span class="Special">,</span> <span class="Constant">'F'</span><span class="Special">,</span> <span class="Constant">'N'</span><span class="Special">,</span> <span class="Constant">'V'</span><span class="Special">,</span> <span class="Constant">'^'</span><span class="Special">,</span> <span class="Constant">'f'</span><span class="Special">,</span> <span class="Constant">'n'</span><span class="Special">,</span> <span class="Constant">'v'</span><span class="Special">,</span> <span class="Constant">'~'</span><span class="Special">,</span> BEL<span class="Special">,</span> SI<span class="Special">,</span> ETB<span class="Special">,</span> USP<span class="Special">,</span> <span class="Constant">'''</span><span class="Special">,</span> <span class="Constant">'/'</span><span class="Special">,</span> <span class="Constant">'7'</span><span class="Special">,</span> <span class="Constant">'?'</span><span class="Special">,</span> <span class="Constant">'G'</span><span class="Special">,</span> <span class="Constant">'O'</span><span class="Special">,</span> <span class="Constant">'W'</span><span class="Special">,</span> <span class="Constant">'_'</span><span class="Special">,</span> <span class="Constant">'g'</span><span class="Special">,</span> <span class="Constant">'o'</span><span class="Special">,</span> <span class="Constant">'w'</span><span class="Special">,</span> DEL <span class="Special">);</span>


Note that type character is an example of an enumeration type containing a mixture of identifiers and characters. Also, the characters '0' and '1' are members of both bit and character . Where '0' or '1' occur in a program, the context will be used to determine which type is being used.

<h4>2.2.5. Arrays</h4>
An array in VHDL is an indexed collection of elements all of the same type. Arrays may be one-dimensional (with one index) or multidimensional (with a number of indices). In addition, an array type may be constrained, in which the bounds for an index are established when the type is defined, or unconstrained, in which the bounds are established subsequently.
The syntax for declaring an array type is:

<span class="Constant">array_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">unconstrained_array_definition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constrained_array_definition</span>

<span class="Constant">unconstrained_array_definition </span><span class="PreProc">::=</span>
<span class="Statement">    array ( </span><span class="bnfLine">index_subtype_definition</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">index_subtype_definition</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement">  ) of </span><span class="bnfLine"><i>element</i>_subtype_indication</span>

<span class="Constant">constrained_array_definition </span><span class="PreProc">::=</span>
<span class="Statement">    array </span><span class="bnfLine">index_constraint</span><span class="Statement"> of </span><span class="bnfLine"><i>element</i>_subtype_indication</span>

<span class="Constant">index_subtype_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> range &lt;&gt;</span>

<span class="Constant">index_constraint </span><span class="PreProc">::=</span>
<span class="Statement">    ( </span><span class="bnfLine">discrete_range</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">discrete_range</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement">  )</span>

<span class="Constant">discrete_range </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>discrete</i>_subtype_indication</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">range_term</span>


Subtypes, referred to in this syntax specification, will be discussed in detail in Section2.2.7.
Some examples of constrained array type declarations:

    <span class="Statement">type</span> word <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span><span class="Constant">31</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">)</span> <span class="Statement">of</span> <span class="Type">bit</span><span class="Special">;</span>
    <span class="Statement">type</span> memory <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span>address<span class="Special">)</span> <span class="Statement">of</span> word<span class="Special">;</span>
    <span class="Statement">type</span> transform <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span><span class="Constant">1</span> <span class="Statement">to</span> <span class="Constant">4</span><span class="Special">,</span> <span class="Constant">1</span> <span class="Statement">to</span> <span class="Constant">4</span><span class="Special">)</span> <span class="Statement">of</span> <span class="Type">real</span><span class="Special">;</span>
    <span class="Statement">type</span> register_bank <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span>byte <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">132</span><span class="Special">)</span> <span class="Statement">of</span> <span class="Type">integer</span><span class="Special">;</span>


An example of an unconstrained array type declaration:

    <span class="Statement">type</span> vector <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span><span class="Type">integer</span> <span class="Statement">range</span> <span class="Special">&lt;&gt;)</span> <span class="Statement">of</span> <span class="Type">real</span><span class="Special">;</span>


The symbol ‘&lt;&gt;’ (called a box) can be thought of as a place-holder for the index range, which will be filled in later when the array type is used. For example, an object might be declared to be a vector of 20 elements by giving its type as:

    vector<span class="Special">(</span><span class="Constant">1</span> <span class="Statement">to</span> <span class="Constant">20</span><span class="Special">)</span>


There are two predefined array types, both of which are unconstrained.  They are defined as:

    <span class="Statement">type</span> <span class="Type">string</span> <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span> <span class="Type">positive</span> <span class="Statement">range</span> <span class="Special">&lt;&gt;</span> <span class="Special">)</span> <span class="Statement">of</span> <span class="Type">character</span><span class="Special">;</span>
    <span class="Statement">type</span> <span class="Type">bit_vector</span> <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span> <span class="Type">natural</span> <span class="Statement">range</span> <span class="Special">&lt;&gt;</span> <span class="Special">)</span> <span class="Statement">of</span> <span class="Type">bit</span><span class="Special">;</span>


The types positive and natural are subtypes of integer, defined in Section2.2.7 below. The type bit_vector is particularly useful in modelling binary coded representations of values in simulations of digital systems.
An element of an array object can referred to by indexing the name of the object. For example, suppose a and b are one- and two-dimensional array objects respectively. Then the indexed names a(1) and b(1, 1) refer to elements of these arrays. Furthermore, a contiguous slice of a one dimensional array can be referred to by using a range as an index. For example a(8 to 15) is an eight-element array which is part of the array a.
Sometimes you may need to write a literal value of an array type. This can be done using an array aggregate, which is a list of element values.  Suppose we have an array type declared as:

    <span class="Statement">type</span> a <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span><span class="Constant">1</span> <span class="Statement">to</span> <span class="Constant">4</span><span class="Special">)</span> <span class="Statement">of</span> <span class="Type">character</span><span class="Special">;</span>


and we want to write a value of this type containing the elements 'f', 'o', 'o', 'd' in that order. We could write an aggregate with positional association as follows:

    <span class="Special">(</span><span class="Constant">'f'</span><span class="Special">,</span> <span class="Constant">'o'</span><span class="Special">,</span> <span class="Constant">'o'</span><span class="Special">,</span> <span class="Constant">'d'</span><span class="Special">)</span>


in which the elements are listed in the order of the index range, starting with the left bound of the range. Alternatively, we could write an aggregate with named association:

    <span class="Special">(</span><span class="Constant">1</span> <span class="Statement">=&gt;</span> <span class="Constant">'f'</span><span class="Special">,</span> <span class="Constant">3</span> <span class="Statement">=&gt;</span> <span class="Constant">'o'</span><span class="Special">,</span> <span class="Constant">4</span> <span class="Statement">=&gt;</span> <span class="Constant">'d'</span><span class="Special">,</span> <span class="Constant">2</span> <span class="Statement">=&gt;</span> <span class="Constant">'o'</span><span class="Special">)</span>


In this case, the index for each element is explicitly given, so the elements can be in any order. Positional and named association can be mixed within an aggregate, provided all the positional associations come first. Also, the word others can be used in place of an index in a named association, indicating a value to be used for all elements not explicitly mentioned. For example, the same value as above could be written as:

    <span class="Special">(</span><span class="Constant">'f'</span><span class="Special">,</span> <span class="Constant">4</span> <span class="Statement">=&gt;</span> <span class="Constant">'d'</span><span class="Special">,</span> <span class="Statement">others</span> <span class="Statement">=&gt;</span> <span class="Constant">'o'</span><span class="Special">)</span>


<h4>2.2.6. Records</h4>
VHDL provides basic facilities for records, which are collections of named elements of possibly different types. The syntax for declaring record types is:

<span class="Constant">record_type_definition </span><span class="PreProc">::=</span>
<span class="Statement">    record</span>
<span class="Statement">        </span><span class="bnfLine">element_declaration</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">element_declaration</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">    end record </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>record_type</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">element_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfLine">element_subtype_definition</span><span class="Statement"> ;</span>

<span class="Constant">identifier_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">identifier</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">element_subtype_definition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subtype_indication</span>


An example record type declaration:

    <span class="Statement">type</span> instruction <span class="Statement">is</span>
        <span class="Statement">record</span>
            op_code : processor_op<span class="Special">;</span>
            address_mode : mode<span class="Special">;</span>
            operand1<span class="Special">,</span> operand2: <span class="Type">integer</span> <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">15</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">record</span> <span class="Special">;</span>


When you need to refer to a field of a record object, you use a selected name. For example, suppose that r is a record object containing a field called f. Then the name r.f refers to that field.
As for arrays, aggregates can be used to write literal values for records.  Both positional and named association can be used, and the same rules apply, with record field names being used in place of array index names.

<h4>2.2.7. Subtypes</h4>
The use of a subtype allows the values taken on by an object to be restricted or constrained subset of some base type. The syntax for declaring a subtype is:

<span class="Constant">subtype_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    subtype </span><span class="bnfLine">identifier</span><span class="Statement"> is </span><span class="bnfLine">subtype_indication</span><span class="Statement"> ;</span>

<span class="Constant">subtype_indication </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>resolution_function</i>_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">type_mark</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">constraint</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">type_mark </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>type</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>subtype</i>_name</span>

<span class="Constant">constraint </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">range_constraint</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">index_constraint</span>


There are two cases of subtypes. Firstly a subtype may constrain values from a scalar type to be within a specified range (a range constraint). For example:

    <span class="Statement">subtype</span> pin_count <span class="Statement">is</span> <span class="Type">integer</span> <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">400</span><span class="Special">;</span>
    <span class="Statement">subtype</span> digits <span class="Statement">is</span> <span class="Type">character</span> <span class="Statement">range</span> <span class="Constant">'0'</span> <span class="Statement">to</span> <span class="Constant">'9'</span><span class="Special">;</span>


Secondly, a subtype may constrain an otherwise unconstrained array

    <span class="Statement">type</span> by specifying bounds <span class="Statement">for</span> the indices<span class="Special">.</span> <span class="Statement">For</span> example:
    <span class="Statement">subtype</span> id <span class="Statement">is</span> <span class="Type">string</span><span class="Special">(</span><span class="Constant">1</span> <span class="Statement">to</span> <span class="Constant">20</span><span class="Special">);</span>
    <span class="Statement">subtype</span> word <span class="Statement">is</span> <span class="Type">bit_vector</span><span class="Special">(</span><span class="Constant">31</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>


There are two predefined numeric subtypes, defined as:

    <span class="Statement">subtype</span> <span class="Type">natural</span> <span class="Statement">is</span> <span class="Type">integer</span> <span class="Statement">range</span> <span class="Constant">0</span> <span class="Statement">to</span> highest_integer
    <span class="Statement">subtype</span> <span class="Type">positive</span> <span class="Statement">is</span> <span class="Type">integer</span> <span class="Statement">range</span> <span class="Constant">1</span> <span class="Statement">to</span> highest_integer


<h4>2.2.8. Object Declarations</h4>
An object is a named item in a VHDL description which has a value of a specified type. There are three classes of objects: constants, variables and signals. Only the first two will be discusses in this section; signals will be covered in Section3.2.1. Declaration and use of constants and variables is very much like their use in programming languages.
A constant is an object which is initialised to a specified value when it is created, and which may not be subsequently modified. The syntax of a constant declaration is:

<span class="Constant">constant_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    constant </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


Constant declarations with the initialising expression missing are called deferred constants, and may only appear in package declarations (see Section2.5.3). The initial value must be given in the corresponding package body. Some examples:

    <span class="Statement">constant</span> e : <span class="Type">real</span> <span class="Statement">:=</span> <span class="Constant">2.71828</span><span class="Special">;</span>
    <span class="Statement">constant</span> delay : <span class="Type">Time</span> <span class="Statement">:=</span> <span class="Constant">5 ns</span><span class="Special">;</span>
    <span class="Statement">constant</span> max_size : <span class="Type">natural</span><span class="Special">;</span>


A variable is an object whose value may be changed after it is created.  The syntax for declaring variables is:

<span class="Constant">variable_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> shared </span><span class="bnfOr">]</span><span class="Statement"> variable </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


The initial value expression, if present, is evaluated and assigned to the variable when it is created. If the expression is absent, a default value is assigned when the variable is created. The default value for scalar types is the leftmost value for the type, that is the first in the list of an enumeration type, the lowest in an ascending range, or the highest in a descending range. If the variable is a composite type, the default value is the composition of the default values for each element, based on the element types.
Some examples of variable declarations:

    <span class="Statement">variable</span> count : <span class="Type">natural</span> <span class="Statement">:=</span> <span class="Constant">0</span><span class="Special">;</span>
    <span class="Statement">variable</span> trace : trace_array<span class="Special">;</span>


Assuming the type trace_array is an array of boolean, then the initial value of the variable trace is an array with all elements having the value false.
Given an existing object, it is possible to give an alternate name to the object or part of it. This is done using and alias declaration. The syntax is:

<span class="Constant">alias_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    alias </span><span class="bnfLine">alias_designator</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> : </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> is </span><span class="bnfLine">name</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">signature</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">alias_designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">character_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">operator_symbol</span>


A reference to an alias is interpreted as a reference to the object or part corresponding to the alias. For example:

    <span class="Statement">variable</span> instr : <span class="Type">bit_vector</span><span class="Special">(</span><span class="Constant">31</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
    <span class="Statement">alias</span> op_code : <span class="Type">bit_vector</span><span class="Special">(</span><span class="Constant">7</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">)</span> <span class="Statement">is</span> instr<span class="Special">(</span><span class="Constant">31</span> <span class="Statement">downto</span> <span class="Constant">24</span><span class="Special">);</span>


declares the name op_code to be an alias for the left-most eight bits of instr.

<h4>2.2.9. Attributes</h4>
Types and objects declared in a VHDL description can have additional information, called attributes, associated with them. There are a number of standard pre-defined attributes, and some of those for types and arrays are discussed here. An attribute is referenced using the ‘'’ notation. For example,

    thing'attr


refers to the attribute attr of the type or object thing.
Firstly, for any scalar type or subtype T, the following attributes can be used:

    T<span class="Special">'left</span><span class="Comment"> -- Left bound of T</span>
    T<span class="Special">'right</span><span class="Comment"> -- Right bound of T</span>
    T<span class="Special">'low</span><span class="Comment"> -- Lower bound of T</span>
    T<span class="Special">'high</span><span class="Comment"> -- Upper bound of T</span>


For an ascending range, T'left = T'low, and T'right = T'high. For a descending range, T'left = T'high, and T'right = T'low.
Secondly, for any discrete or physical type or subtype T, X a member of T, and N an integer, the following attributes can be used:

    T<span class="Special">'pos</span><span class="Special">(</span>X<span class="Special">)</span><span class="Comment"> -- Position number of X in T</span>
    T<span class="Special">'val</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Value at position N in T</span>
    T<span class="Special">'leftof</span><span class="Special">(</span>X<span class="Special">)</span><span class="Comment"> -- Value in T which is one position left from X</span>
    T<span class="Special">'rightof</span><span class="Special">(</span>X<span class="Special">)</span><span class="Comment"> -- Value in T which is one position right from X</span>
    T<span class="Special">'pred</span><span class="Special">(</span>X<span class="Special">)</span><span class="Comment"> -- Value in T which is one position lower than X</span>
    T<span class="Special">'succ</span><span class="Special">(</span>X<span class="Special">)</span><span class="Comment"> -- Value in T which is one position higher than X</span>


For an ascending range, T'leftof(X) = T'pred(X), and T'rightof(X) = T'succ(X). For a descending range, T'leftof(X) = T'succ(X), and T'rightof(X) = T'pred(X).
Thirdly, for any array type or object A, and N an integer between 1 and the number of dimensions of A, the following attributes can be used:

    A<span class="Special">'left</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Left bound of index range of dim’n N of A</span>
    A<span class="Special">'right</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Right bound of index range of dim’n N of A</span>
    A<span class="Special">'low</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Lower bound of index range of dim’n N of A</span>
    A<span class="Special">'high</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Upper bound of index range of dim’n N of A</span>
    A<span class="Special">'range</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Index range of dim’n N of A</span>
    A<span class="Special">'reverse_range</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Reverse of index range of dim’n N of A</span>
    A<span class="Special">'length</span><span class="Special">(</span>N<span class="Special">)</span><span class="Comment"> -- Length of index range of dim’n N of A</span>


<h3>2.3. Expressions and Operators</h3>
Expressions in VHDL are much like expressions in other programming languages. An expression is a formula combining primaries with operators. Primaries include names of objects, literals, function calls and parenthesised expressions. Operators are listed in Table 2-1 in order of decreasing precedence.

    <span class="Statement">**</span> <span class="Statement">abs</span> <span class="Statement">not</span>
    <span class="Statement">*</span> <span class="Statement">/</span> <span class="Statement">mod</span> <span class="Statement">rem</span>
    <span class="Statement">+</span> <span class="Special">(</span>sign<span class="Special">)</span> <span class="Statement">-</span> <span class="Special">(</span>sign<span class="Special">)</span>
    <span class="Statement">+</span> <span class="Statement">-</span> <span class="Statement">&amp;</span>
    <span class="Statement">=</span> <span class="Statement">/=</span> <span class="Statement">&lt;</span> <span class="Statement">&lt;=</span> <span class="Statement">&gt;</span> <span class="Statement">&gt;=</span>
    <span class="Statement">and</span>  <span class="Statement">or</span> <span class="Statement">nor</span> <span class="Statement">xor</span> <span class="Statement">nand</span>

Table 2-1. Operators and precedence.

The logical operators and, or, nand, nor, xor and not operate on values of type bit or boolean, and also on one-dimensional arrays of these types. For array operands, the operation is applied between corresponding elements of each array, yielding an array of the same length as the result. For bit and boolean operands, and , or, nand, and nor are ‘short-circuit’ operators, that is they only evaluate their right operand if the left operand does not determine the result. So and and nand only evaluate the right operand if the left operand is true or '1', and or and nor only evaluate the right operand if the left operand is false or '0'.
The relational operators =, /=, &lt;, &lt;=, &gt; and &gt;= must have both operands of the same type, and yield boolean results. The equality operators (= and /=) can have operands of any type. For composite types, two values are equal if all of their corresponding elements are equal. The remaining operators must have operands which are scalar types or one-dimensional arrays of discrete types.
The sign operators (+ and –) and the addition (+) and subtraction (–) operators have their usual meaning on numeric operands. The concatenation operator (&amp;) operates on one-dimensional arrays to form a new array with the contents of the right operand following the contents of the left operand. It can also concatenate a single new element to an array, or two individual elements to form an array. The concatenation operator is most commonly used with strings.
The multiplication (*) and division (/) operators work on integer, floating point and physical types types. The modulus (mod) and remainder (rem) operators only work on integer types. The absolute value (abs) operator works on any numeric type. Finally, the exponentiation (**) operator can have an integer or floating point left operand, but must have an integer right operand. A negative right operand is only allowed if the left operand is a floating point number.

The complete syntax for VHDL expression follows:

<span class="Constant">expression </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> and </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> or </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> xor </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> nand </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> nor </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> xnor </span><span class="bnfLine">relation</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">relation </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">shift_expression</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">relational_operator</span><span class="Statement"> </span><span class="bnfLine">shift_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">shift_expression </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">simple_expression</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">shift_operator</span><span class="Statement"> </span><span class="bnfLine">simple_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">simple_expression </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">sign</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">term</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">adding_operator</span><span class="Statement"> </span><span class="bnfLine">term</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">sign </span><span class="PreProc">::=</span>
<span class="Statement">    + </span><span class="bnfOr">|</span><span class="Statement"> -</span>

<span class="Constant">term </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">factor</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">multiplying_operator</span><span class="Statement"> </span><span class="bnfLine">factor</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">factor </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">primary</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ** </span><span class="bnfLine">primary</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    abs </span><span class="bnfLine">primary</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    not </span><span class="bnfLine">primary</span>

<span class="Constant">primary </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">literal</span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">aggregate</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">function_call</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">qualified_expression</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_conversion</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">allocator</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    ( </span><span class="bnfLine">expression</span><span class="Statement"> )</span>

<span class="Constant">name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">simple_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">operator_symbol</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">selected_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">indexed_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">slice_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_name</span>

<span class="Constant">simple_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span>

<span class="Constant">operator_symbol </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">string_literal</span>

<span class="Constant">selected_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">prefix</span><span class="Statement"> . </span><span class="bnfLine">suffix</span>

<span class="Constant">prefix </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">function_call</span>

<span class="Constant">function_call </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>function</i>_name</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">actual_parameter_part</span><span class="Statement"> ) </span><span class="bnfOr">]</span>

<span class="Constant">actual_parameter_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>parameter</i>_association_list</span>

<span class="Constant">association_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">association_element</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">association_element</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">association_element </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">formal_part</span><span class="Statement"> =&gt; </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">actual_part</span>

<span class="Constant">formal_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">formal_designator</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>function</i>_name</span><span class="Statement"> ( </span><span class="bnfLine">formal_designator</span><span class="Statement"> ) </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ( </span><span class="bnfLine">formal_designator</span><span class="Statement"> )</span>

<span class="Constant">formal_designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>generic</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>port</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>parameter</i>_name</span>

<span class="Constant">actual_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">actual_designator</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>function</i>_name</span><span class="Statement"> ( </span><span class="bnfLine">actual_designator</span><span class="Statement"> ) </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ( </span><span class="bnfLine">actual_designator</span><span class="Statement"> )</span>

<span class="Constant">actual_designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>signal</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>variable</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>file</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    open</span>

<span class="Constant">suffix </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">simple_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">character_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">operator_symbol</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    all</span>

<span class="Constant">indexed_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">prefix</span><span class="Statement"> ( </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> )</span>

<span class="Constant">slice_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">prefix</span><span class="Statement"> ( </span><span class="bnfLine">discrete_range</span><span class="Statement"> )</span>

<span class="Constant">discrete_range </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>discrete</i>_subtype_indication</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">range_term</span>

<span class="Constant">attribute_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">prefix</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">signature</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ' </span><span class="bnfLine">attribute_designator</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">expression</span><span class="Statement"> ) </span><span class="bnfOr">]</span>

<span class="Constant">signature </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">type_mark</span><span class="Statement"> </span><span class="bnfLine">{</span><span class="Statement"> , </span><span class="bnfLine">type_mark</span><span class="Statement"> </span><span class="bnfLine">}</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> return </span><span class="bnfLine">type_mark</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">attribute_designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>attribute</i>_simple_name</span>

<span class="Constant">literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">numeric_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">enumeration_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">string_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">bit_string_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    null</span>

<span class="Constant">numeric_literal </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">abstract_literal</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">physical_literal</span>

<span class="Constant">aggregate </span><span class="PreProc">::=</span>
<span class="Statement">    ( </span><span class="bnfLine">element_association</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">element_association</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> )</span>

<span class="Constant">element_association </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">choices</span><span class="Statement"> =&gt; </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">expression</span>

<span class="Constant">qualified_expression </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ' ( </span><span class="bnfLine">expression</span><span class="Statement"> ) </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ' </span><span class="bnfLine">aggregate</span>

<span class="Constant">type_conversion </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ( </span><span class="bnfLine">expression</span><span class="Statement"> )</span>

<span class="Constant">allocator </span><span class="PreProc">::=</span>
<span class="Statement">    new </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    new </span><span class="bnfLine">qualified_expression</span>

<span class="Constant">multiplying_operator </span><span class="PreProc">::=</span>
<span class="Statement">    * </span><span class="bnfOr">|</span><span class="Statement"> / </span><span class="bnfOr">|</span><span class="Statement"> mod </span><span class="bnfOr">|</span><span class="Statement"> rem</span>

<span class="Constant">adding_operator </span><span class="PreProc">::=</span>
<span class="Statement">    + </span><span class="bnfOr">|</span><span class="Statement"> - </span><span class="bnfOr">|</span><span class="Statement"> &amp;</span>

<span class="Constant">shift_operator </span><span class="PreProc">::=</span>
<span class="Statement">    sll </span><span class="bnfOr">|</span><span class="Statement">   </span><span class="Comment">-- (L := (L[L'length - 1, 0] &amp; T'left)) x R</span>
<span class="Statement">    srl </span><span class="bnfOr">|</span><span class="Statement">   </span><span class="Comment">-- (L := (T'left &amp; L[L'length - 1, 0])) x R</span>
<span class="Statement">    sla </span><span class="bnfOr">|</span><span class="Statement">   </span><span class="Comment">-- (L := (L[L'length - 1, 0] &amp; L(L'right))) x R</span>
<span class="Statement">    sra </span><span class="bnfOr">|</span><span class="Statement">   </span><span class="Comment">-- (L := (L(L'left) &amp; L[L'length - 1, 0])) x R</span>
<span class="Statement">    rol </span><span class="bnfOr">|</span><span class="Statement">   </span><span class="Comment">-- (L := (L[L'length - 1, 0] &amp; L(L'left))) x R</span>
<span class="Statement">    ror     </span><span class="Comment">-- (L := (L(L'right) &amp; L[L'length - 1, 0])) x R</span>

<span class="Constant">relational_operator </span><span class="PreProc">::=</span>
<span class="Statement">    = </span><span class="bnfOr">|</span><span class="Statement"> /= </span><span class="bnfOr">|</span><span class="Statement"> &lt; </span><span class="bnfOr">|</span><span class="Statement"> &lt;= </span><span class="bnfOr">|</span><span class="Statement"> &gt; </span><span class="bnfOr">|</span><span class="Statement"> &gt;=</span>



<h3>2.4. Sequential Statements</h3>
VHDL contains a number of facilities for modifying the state of objects and controlling the flow of execution of models. These are discussed in this section.

<h4>2.4.1. Variable Assignment</h4>
As in other programming languages, a variable is given a new value using an assignment statement. The syntax is:

<span class="Constant">variable_assignment_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">target</span><span class="Statement"> := </span><span class="bnfLine">expression</span><span class="Statement"> ;</span>

<span class="Constant">label </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span>

<span class="Constant">target </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">aggregate</span>


In the simplest case, the target of the assignment is an object name, and the value of the expression is given to the named object. The object and the value must have the same base type.
If the target of the assignment is an aggregate, then the elements listed must be object names, and the value of the expression must be a composite value of the same type as the aggregate. Firstly, all the names in the aggregate are evaluated, then the expression is evaluated, and lastly the components of the expression value are assigned to the named variables.  This is effectively a parallel assignment. For example, if a variable r is a record with two fields a and b, then they could be exchanged by writing

    <span class="Special">(</span>a <span class="Statement">=&gt;</span> r<span class="Special">.</span>b<span class="Special">,</span> b <span class="Statement">=&gt;</span> r<span class="Special">.</span>a<span class="Special">)</span> <span class="Statement">:=</span> r


(Note that this is an example to illustrate how such an assignment works; it is not an example of good programming practice!)

<h4>2.4.2. If Statement</h4>
The if statement allows selection of statements to execute depending on one or more conditions. The syntax is:

<span class="Constant">if_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>if</i>_label</span><span class="Statement"> : </span><span class="bnfOr">]</span><span class="Statement"> if </span><span class="bnfLine">condition</span><span class="Statement"> then </span><span class="bnfLine">sequence_of_statements</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> elsif </span><span class="bnfLine">condition</span><span class="Statement"> then </span><span class="bnfLine">sequence_of_statements</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> else </span><span class="bnfLine">sequence_of_statements</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    end if </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>if</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


The conditions are expressions resulting in boolean values. The conditions are evaluated successively until one found that yields the value true. In that case the corresponding statement list is executed. Otherwise, if the else clause is present, its statement list is executed.

<h4>2.4.3. Case Statement</h4>
The case statement allows selection of statements to execute depending on the value of a selection expression. The syntax is:

<span class="Constant">case_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>case</i>_label</span><span class="Statement"> : </span><span class="bnfOr">]</span><span class="Statement"> case </span><span class="bnfLine">expression</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">case_statement_alternative</span>
<span class="Statement">        </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">case_statement_alternative</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">    end case </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>case</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">case_statement_alternative </span><span class="PreProc">::=</span>
<span class="Statement">    when </span><span class="bnfLine">choices</span><span class="Statement"> =&gt; </span><span class="bnfLine">sequence_of_statements</span>

<span class="Constant">choices </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">choice</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfOr">|</span><span class="Statement"> </span><span class="bnfLine">choice</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">choice </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">simple_expression</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">discrete_range</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>element</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    others</span>


The selection expression must result in either a discrete type, or a one dimensional array of characters. The alternative whose choice list includes the value of the expression is selected and the statement list executed. Note that all the choices must be distinct, that is, no value may be duplicated. Furthermore, all values must be represented in the choice lists, or the special choice others must be included as the last alternative. If no choice list includes the value of the expression, the others alternative is selected. If the expression results in an array, then the choices may be strings or bit strings.
Some examples of case statements:

    <span class="Statement">case</span> element_colour <span class="Statement">of</span>
        <span class="Statement">when</span> red <span class="Statement">=&gt;</span> statements <span class="Statement">for</span> red<span class="Special">;</span>
        <span class="Statement">when</span> green | blue <span class="Statement">=&gt;</span> statements <span class="Statement">for</span> green <span class="Statement">or</span> blue<span class="Special">;</span>
        <span class="Statement">when</span> orange <span class="Statement">to</span> turquoise <span class="Statement">=&gt;</span> statements <span class="Statement">for</span> these colours<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">case</span> <span class="Special">;</span>

    <span class="Statement">case</span> opcode <span class="Statement">of</span>
        <span class="Statement">when</span> <span class="Constant">X&quot;00&quot;</span> <span class="Statement">=&gt;</span> perform_add<span class="Special">;</span>
        <span class="Statement">when</span> <span class="Constant">X&quot;01&quot;</span> <span class="Statement">=&gt;</span> perform_subtract<span class="Special">;</span>
        <span class="Statement">when</span> <span class="Statement">others</span> <span class="Statement">=&gt;</span> signal_illegal_opcode<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">case</span> <span class="Special">;</span>


<h4>2.4.4. Loop Statements</h4>
VHDL has a basic loop statement, which can be augmented to form the usual while and for loops seen in other programming languages. The syntax of the loop statement is:

<span class="Constant">loop_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>loop</i>_label</span><span class="Statement"> : </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">iteration_scheme</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> loop</span>
<span class="Statement">        </span><span class="bnfLine">sequence_of_statements</span>
<span class="Statement">    end loop </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>loop</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">iteration_scheme </span><span class="PreProc">::=</span>
<span class="Statement">    while </span><span class="bnfLine">condition</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    for </span><span class="bnfLine"><i>loop</i>_parameter_specification</span>

<span class="Constant">parameter_specification </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> in </span><span class="bnfLine">discrete_range</span>

<span class="Constant">sequence_of_statements </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">sequential_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>


If the iteration scheme is omitted, we get a loop which will repeat the enclosed statements indefinitely. An example of such a basic loop is:

    <span class="Statement">loop</span>
        do_something<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">loop</span> <span class="Special">;</span>


The while iteration scheme allows a test condition to be evaluated before each iteration. The iteration only proceeds if the test evaluates to true. If the test is false, the loop statement terminates. An example:

    <span class="Statement">while</span> index <span class="Statement">&lt;</span> length <span class="Statement">and</span> str<span class="Special">(</span>index<span class="Special">)</span> <span class="Statement">/=</span> <span class="Constant">' '</span> <span class="Statement">loop</span>
        index <span class="Statement">:=</span> index <span class="Statement">+</span> <span class="Constant">1</span><span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">loop</span><span class="Special">;</span>

The for iteration scheme allows a specified number of iterations. The loop parameter specification declares an object which takes on successive values from the given range for each iteration of the loop. Within the statements enclosed in the loop, the object is treated as a constant, and so may not be assigned to. The object does not exist beyond execution of the loop statement. An example:

    <span class="Statement">for</span> item <span class="Statement">in</span> <span class="Constant">1</span> <span class="Statement">to</span> last_item <span class="Statement">loop</span>
        table<span class="Special">(</span>item<span class="Special">)</span> <span class="Statement">:=</span> <span class="Constant">0</span><span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">loop</span> <span class="Special">;</span>


There are two additional statements which can be used inside a loop to modify the basic pattern of iteration. The ‘next’ statement terminates execution of the current iteration and starts the subsequent iteration. The ‘exit’ statement terminates execution of the current iteration and terminates the loop. The syntax of these statements is:

<span class="Constant">next_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> next </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>loop</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> when </span><span class="bnfLine">condition</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">exit_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> exit </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>loop</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> when </span><span class="bnfLine">condition</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


If the loop label is omitted, the statement applies to the inner-most enclosing loop, otherwise it applies to the named loop. If the when clause is present but the condition is false, the iteration continues normally. Some examples:

    <span class="Statement">for</span> i <span class="Statement">in</span> <span class="Constant">1</span> <span class="Statement">to</span> max_str_len <span class="Statement">loop</span>
        a<span class="Special">(</span>i<span class="Special">)</span> <span class="Statement">:=</span> buf<span class="Special">(</span>i<span class="Special">);</span>
        <span class="Statement">exit</span> <span class="Statement">when</span> buf<span class="Special">(</span>i<span class="Special">)</span> <span class="Statement">=</span> NUL<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">loop</span><span class="Special">;</span>

    outer_loop: <span class="Statement">loop</span>
        inner_loop: <span class="Statement">loop</span>
            do_something<span class="Special">;</span>
            <span class="Statement">next</span> outer_loop <span class="Statement">when</span> temp <span class="Statement">=</span> <span class="Constant">0</span><span class="Special">;</span>
            do_something_else<span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">loop</span> inner_loop<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">loop</span> outer_loop<span class="Special">;</span>


<h4>2.4.5. Null Statement</h4>
The null statement has no effect. It may be used to explicitly show that no action is required in certain cases. It is most often used in case statements, where all possible values of the selection expression must be listed as choices, but for some choices no action is required. For example:

    <span class="Statement">case</span> controller_command <span class="Statement">is</span>
        <span class="Statement">when</span> forward <span class="Statement">=&gt;</span> engage_motor_forward<span class="Special">;</span>
        <span class="Statement">when</span> reverse <span class="Statement">=&gt;</span> engage_motor_reverse<span class="Special">;</span>
        <span class="Statement">when</span> idle <span class="Statement">=&gt;</span> <span class="Statement">null</span><span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">case</span><span class="Special">;</span>


<h4>2.4.6. Assertions</h4>
An assertion statement is used to verify a specified condition and to report if the condition is violated. The syntax is:

<span class="Constant">assertion_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">assertion</span><span class="Statement"> ;</span>

<span class="Constant">assertion </span><span class="PreProc">::=</span>
<span class="Statement">    assert </span><span class="bnfLine">condition</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> report </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> severity </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">]</span>


If the report clause is present, the result of the expression must be a string.  This is a message which will be reported if the condition is false. If it is omitted, the default message is &quot;Assertion violation&quot;. If the severity clause is present the expression must be of the type severity_level. If it is omitted, the default is error. A simulator may terminate execution if an assertion violation occurs and the severity value is greater than some implementation dependent threshold. Usually the threshold will be under user control.

<h3>2.5. Subprograms and Packages</h3>
Like other programming languages, VHDL provides subprogram facilities in the form of procedures and functions. VHDL also provided a package facility for collecting declarations and objects into modular units.  Packages also provide a measure of data abstraction and information hiding.

<h4>2.5.1. Procedures and Functions</h4>
Procedure and function subprograms are declared using the syntax:

<span class="Constant">subprogram_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_specification</span><span class="Statement"> ;</span>

<span class="Constant">subprogram_specification </span><span class="PreProc">::=</span>
<span class="Statement">    procedure </span><span class="bnfLine">designator</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">formal_parameter_list</span><span class="Statement"> ) </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> pure </span><span class="bnfOr">|</span><span class="Statement"> impure </span><span class="bnfOr">]</span><span class="Statement"> function </span><span class="bnfLine">designator</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">formal_parameter_list</span><span class="Statement"> ) </span><span class="bnfOr">]</span><span class="Statement"> return </span><span class="bnfLine">type_mark</span>

<span class="Constant">designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">operator_symbol</span>


A subprogram declaration in this form simply names the subprogram and specifies the parameters required. The body of statements defining the behaviour of the subprogram is deferred. For function subprograms, the declaration also specifies the type of the result returned when the function is called. This form of subprogram declaration is typically used in package specifications (see Section 2.5.3), where the subprogram body is given in the package body, or to define mutually recursive procedures.
The syntax for specifying the formal parameters of a subprogram is:

<span class="Constant">formal_parameter_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>parameter</i>_interface_list</span>

<span class="Constant">interface_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">interface_element</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> ; </span><span class="bnfLine">interface_element</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">interface_element </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">interface_declaration</span>

<span class="Constant">interface_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">interface_constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">interface_signal_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">interface_variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">interface_file_declaration</span>

<span class="Constant">interface_constant_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> constant </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfOr">[</span><span class="Statement"> in </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine"><i>static</i>_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">interface_signal_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> signal </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">mode</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> bus </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine"><i>static</i>_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">interface_variable_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> variable </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">mode</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine"><i>static</i>_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">interface_file_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    file </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfLine">subtype_indication</span>

<span class="Constant">mode </span><span class="PreProc">::=</span>
<span class="Statement">    in </span><span class="bnfOr">|</span><span class="Statement"> out </span><span class="bnfOr">|</span><span class="Statement"> inout </span><span class="bnfOr">|</span><span class="Statement"> buffer </span><span class="bnfOr">|</span><span class="Statement"> linkage</span>


For now we will only consider constant and variable parameters, although signals can also be used(see Chapter3). Some examples will clarify this syntax. Firstly, a simple example of a procedure with no parameters:

    <span class="Statement">procedure</span> reset<span class="Special">;</span>


This simply defines reset as a procedure with no parameters, whose statement body will be given subsequently in the VHDL program. A procedure call to reset would be:

    reset<span class="Special">;</span>


Secondly, here is a declaration of a procedure with some parameters:

    <span class="Statement">procedure</span> increment_reg<span class="Special">(</span>
        <span class="Statement">variable</span> reg : <span class="Statement">inout</span> word_32<span class="Special">;</span>
        <span class="Statement">constant</span> incr : <span class="Statement">in</span> <span class="Type">integer</span> <span class="Statement">:=</span> <span class="Constant">1</span>
    <span class="Special">);</span>


In this example, the procedure increment_reg has two parameters, the first called reg and the second called incr. Reg is a variable parameter, which means that in the subprogram body, it is treated as a variable object and may be assigned to. This means that when the procedure is called, the actual parameter associated with reg must itself be a variable. The mode of reg is inout, which means that reg can be both read and assigned to. Other possible modes for subprogram parameters are in, which means that the parameter may only be read, and out, which means that the parameter may only be assigned to. If the mode is inout or out, then the word variable can be omitted and is assumed.
The second parameter, incr, is a constant parameter, which means that it is treated as a constant object in the subprogram statement body, and may not be assigned to. The actual parameter associated with incr when the procedure is called must be an expression. Given the mode of the parameter, in, the word constant could be omitted and assumed. The expression after the assignment operator is a default expression, which is used if no actual parameter is associated with incr in a call to the procedure.
A call to a subprogram includes a list of actual parameters to be associated with the formal parameters. This association list can be position, named, or a combination of both. (Compare this with the format of aggregates for values of composite types.) A call with positional association lists the actual parameters in the same order as the formals. For example:

    increment_reg<span class="Special">(</span>index_reg<span class="Special">,</span> offset <span class="Statement">-</span> <span class="Constant">2</span><span class="Special">);</span><span class="Comment"> -- add value to index_reg</span>
    increment_reg<span class="Special">(</span>prog_counter<span class="Special">);</span><span class="Comment"> -- add 1 (default) to prog_counter</span>


A call with named association explicitly gives the formal parameter name to be associated with each actual parameter, so the parameters can be in any order. For example:

    increment_reg<span class="Special">(</span>incr <span class="Statement">=&gt;</span> offset <span class="Statement">-</span> <span class="Constant">2</span><span class="Special">,</span> reg <span class="Statement">=&gt;</span> index_reg<span class="Special">);</span>
    increment_reg<span class="Special">(</span>reg <span class="Statement">=&gt;</span> prog_counter<span class="Special">);</span>


Note that the second call in each example does not give a value for the formal parameter incr, so the default value is used.
Thirdly, here is an example of function subprogram declaration:

    <span class="Statement">function</span> byte_to_int<span class="Special">(</span>byte : word_8<span class="Special">)</span> <span class="Statement">return</span> <span class="Type">integer</span><span class="Special">;</span>


The function has one parameter. For functions, the parameter mode must be in, and this is assumed if not explicitly specified. If the parameter class is not specified it is assumed to be constant. The value returned by the body of this function must be an integer.
When the body of a subprogram is specified, the syntax used is:

<span class="Constant">subprogram_body </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_specification</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">subprogram_declarative_part</span>
<span class="Statement">    begin</span>
<span class="Statement">        </span><span class="bnfLine">subprogram_statement_part</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">subprogram_kind</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">designator</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">subprogram_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">subprogram_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">subprogram_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_body</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subtype_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">alias_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_template_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>

<span class="Constant">subprogram_statement_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">sequential_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">subprogram_kind </span><span class="PreProc">::=</span>
<span class="Statement">    procedure </span><span class="bnfOr">|</span><span class="Statement"> function</span>


The declarative items listed after the subprogram specification declare things which are to be used locally within the subprogram body. The names of these items are not visible outside of the subprogram, but are visible inside locally declared subprograms. Furthermore, these items shadow any things with the same names declared outside the subprogram.
When the subprogram is called, the statements in the body are executed until either the end of the statement list is encountered, or a return statement is executed. The syntax of a return statement is:

<span class="Constant">return_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> return </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


If a return statement occurs in a procedure body, it must not include an expression. There must be at least one return statement in a function body, it must have an expression, and the function must complete by executing a return statement. The value of the expression is the valued returned to the function call.
Another point to note about function subprograms is that they may not have any side-effects. This means that no visible variable declared outside the function body may be assigned to or altered by the function. This includes passing a non-local variable to a procedure as a variable parameter with mode out or inout. The important result of this rule is that functions can be called without them having any effect on the environment of the call.
An example of a function body:

    <span class="Statement">function</span> byte_to_int<span class="Special">(</span>byte : word_8<span class="Special">)</span> <span class="Statement">return</span> <span class="Type">integer</span> <span class="Statement">is</span>
        <span class="Statement">variable</span> result : <span class="Type">integer</span> <span class="Statement">:=</span> <span class="Constant">0</span><span class="Special">;</span>
    <span class="Statement">begin</span>
        <span class="Statement">for</span> index <span class="Statement">in</span> <span class="Constant">0</span> <span class="Statement">to</span> <span class="Constant">7</span> <span class="Statement">loop</span>
            result <span class="Statement">:=</span> result <span class="Statement">*</span> <span class="Constant">2</span> <span class="Statement">+</span> <span class="Type">bit'</span>pos<span class="Special">(</span>byte<span class="Special">(</span>index<span class="Special">));</span>
        <span class="Statement">end</span> <span class="Statement">loop</span> <span class="Special">;</span>
        <span class="Statement">return</span> result<span class="Special">;</span>
    <span class="Statement">end</span> byte_to_int<span class="Special">;</span>


<h4>2.5.2. Overloading</h4>
VHDL allows two subprograms to have the same name, provided the number or base types of parameters differs. The subprogram name is then said to be overloaded. When a subprogram call is made using an overloaded name, the number of actual parameters, their order, their base types and the corresponding formal parameter names (if named association is used) are used to determine which subprogram is meant. If the call is a function call, the result type is also used. For example, suppose we declared the two subprograms:

    <span class="Statement">function</span> check_limit<span class="Special">(</span>value : <span class="Type">integer</span><span class="Special">)</span> <span class="Statement">return</span> <span class="Type">boolean</span><span class="Special">;</span>
    <span class="Statement">function</span> check_limit<span class="Special">(</span>value : word_32<span class="Special">)</span> <span class="Statement">return</span> <span class="Type">boolean</span><span class="Special">;</span>


Then which of the two functions is called depends on whether a value of type integer or word_8 is used as the actual parameter. So

    test <span class="Statement">:=</span> check_limit<span class="Special">(</span><span class="Constant">4095</span><span class="Special">)</span>


would call the first function, and

    test <span class="Statement">:=</span> check_limit<span class="Special">(</span><span class="Constant">X&quot;0000_0FFF&quot;</span><span class="Special">)</span>


would call the second function.
The designator used to define a subprogram can be either an identifier or a string representing any of the operator symbols listed in Section2.3.  The latter case allows extra operand types to be defined for those operators.  For example, the addition operator might be overloaded to add word_32 operands by declaring a function:

    <span class="Statement">function</span> <span class="Constant">&quot;+&quot;</span> <span class="Special">(</span>a<span class="Special">,</span> b : word_32<span class="Special">)</span> <span class="Statement">return</span> word_32 <span class="Statement">is</span>
    <span class="Statement">begin</span>
        <span class="Statement">return</span> int_to_word_32<span class="Special">(</span> word_32_to_int<span class="Special">(</span>a<span class="Special">)</span> <span class="Statement">+</span> word_32_to_int<span class="Special">(</span>b<span class="Special">)</span> <span class="Special">);</span>
    <span class="Statement">end</span> <span class="Constant">&quot;+&quot;</span><span class="Special">;</span>


Within the body of this function, the addition operator is used to add integers, since its operands are both integers. However, in the expression:

    <span class="Constant">X&quot;1000_0010&quot;</span> <span class="Statement">+</span> <span class="Constant">X&quot;0000_FFD0&quot;</span>


the newly declared function is called, since the operands to the addition operator are both of type word_32. Note that it is also possible to call operators using the prefix notation used for ordinary subprogram calls, for example:

    <span class="Constant">&quot;+&quot;</span> <span class="Special">(</span><span class="Constant">X&quot;1000_0010&quot;</span><span class="Special">,</span> <span class="Constant">X&quot;0000_FFD0&quot;</span><span class="Special">)</span>


<h4>2.5.3. Package and Package Body Declarations</h4>
A package is a collection of types, constants, subprograms and possibly other things, usually intended to implement some particular service or to isolate a group of related items. In particular, the details of constant values and subprogram bodies can be hidden from users of a package, with only their interfaces made visible.
A package may be split into two parts: a package declaration, which defines its interface, and a package body, which defines the deferred details. The body part may be omitted if there are no deferred details. The syntax of a package declaration is:

<span class="Constant">package_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    package </span><span class="bnfLine">identifier</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">package_declarative_part</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> package </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>package</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">package_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">package_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">package_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subtype_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">signal_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>shared</i>_variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">alias_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">component_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">disconnection_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_template_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>


The declarations define things which are to be visible to users of the package, and which are also visible inside the package body. (There are also other kinds of declarations which can be included, but they are not discussed here.)
An example of a package declaration:

    <span class="Statement">package</span> data_types <span class="Statement">is</span>
        <span class="Statement">subtype</span> address <span class="Statement">is</span> <span class="Type">bit_vector</span><span class="Special">(</span><span class="Constant">24</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
        <span class="Statement">subtype</span> data <span class="Statement">is</span> <span class="Type">bit_vector</span><span class="Special">(</span><span class="Constant">15</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
        <span class="Statement">constant</span> vector_table_loc : address<span class="Special">;</span>
        <span class="Statement">function</span> data_to_int<span class="Special">(</span>value : data<span class="Special">)</span> <span class="Statement">return</span> <span class="Type">integer</span><span class="Special">;</span>
        <span class="Statement">function</span> int_to_data<span class="Special">(</span>value : <span class="Type">integer</span><span class="Special">)</span> <span class="Statement">return</span> data<span class="Special">;</span>
    <span class="Statement">end</span> data_types<span class="Special">;</span>


In this example, the value of the constant vector_table_loc and the bodies of the two functions are deferred, so a package body needs to be given.
The syntax for a package body is:

<span class="Constant">package_body </span><span class="PreProc">::=</span>
<span class="Statement">    package </span><span class="bnfLine">body</span><span class="Statement"> </span><span class="bnfLine"><i>package</i>_simple_name</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">package_body_declarative_part</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> package  body </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>package</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">package_body_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">package_body_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">package_body_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_body</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subtype_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>shared</i>_variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">alias_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_template_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>


Note that subprogram bodies may be included in a package body, whereas only subprogram interface declarations may be included in the package interface declaration.
The body for the package data_types shown above might be written as:

    <span class="Statement">package</span> <span class="Statement">body</span> data_types <span class="Statement">is</span>
        <span class="Statement">constant</span> vector_table_loc : address <span class="Statement">:=</span> <span class="Constant">X&quot;FFFF00&quot;</span><span class="Special">;</span>
        <span class="Statement">function</span> data_to_int<span class="Special">(</span>value : data<span class="Special">)</span> <span class="Statement">return</span> <span class="Type">integer</span> <span class="Statement">is</span>
            <span class="Statement">body</span><span class="Statement">-</span><span class="Statement">of</span><span class="Statement">-</span>data_to_int
        <span class="Statement">end</span> data_to_int<span class="Special">;</span>
        <span class="Statement">function</span> int_to_data<span class="Special">(</span>value : <span class="Type">integer</span><span class="Special">)</span> <span class="Statement">return</span> data <span class="Statement">is</span>
            <span class="Statement">body</span><span class="Statement">-</span><span class="Statement">of</span><span class="Statement">-</span>int_to_data
        <span class="Statement">end</span> int_to_data<span class="Special">;</span>
    <span class="Statement">end</span> data_types<span class="Special">;</span>


In this package body, the value for the constant is specified, and the function bodies are given. The subtype declarations are not repeated, as those in the package declarations are visible in the package body.

<h4>2.5.4. Package Use and Name Visibility</h4>
Once a package has been declared, items declared within it can be used by prefixing their names with the package name. For example, given the package declaration in Section2.4.3 above, the items declared might be used as follows:

    <span class="Statement">variable</span> PC : data_types<span class="Special">.</span>address<span class="Special">;</span>
    int_vector_loc <span class="Statement">:=</span> data_types<span class="Special">.</span>vector_table_loc <span class="Statement">+</span> <span class="Constant">4</span> <span class="Statement">*</span> int_level<span class="Special">;</span>
    offset <span class="Statement">:=</span> data_types<span class="Special">.</span>data_to_int<span class="Special">(</span>offset_reg<span class="Special">);</span>


Often it is convenient to be able to refer to names from a package without having to qualify each use with the package name. This may be done using a use clause in a declaration region. The syntax is:

<span class="Constant">use_clause </span><span class="PreProc">::=</span>
<span class="Statement">    use </span><span class="bnfLine">selected_name</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">selected_name</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement">  ;</span>

<span class="Constant">selected_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">prefix</span><span class="Statement"> . </span><span class="bnfLine">suffix</span>


The effect of the use clause is that all of the listed names can subsequently be used without having to prefix them. If all of the declared names in a package are to be used in this way, you can use the special suffix all, for example:

    <span class="Statement">use</span> data_types<span class="Special">.</span><span class="Statement">all</span><span class="Special">;</span>


<h2>3. VHDL Describes Structure</h2>
In Section 1.1 we introduced some terminology for describing the structure of a digital system. In this chapter, we will look at how structure is described in VHDL.

<h3>3.1. Entity Declarations</h3>
A digital system is usually designed as a hierarchical collection of modules. Each module has a set of ports which constitute its interface to the outside world. In VHDL, an entity is such a module which may be used as a component in a design, or which may be the top level module of the design.
The syntax for declaring an entity is:

<span class="Constant">entity_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    entity </span><span class="bnfLine">identifier</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">entity_header</span>
<span class="Statement">        </span><span class="bnfLine">entity_declarative_part</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> begin</span>
<span class="Statement">        </span><span class="bnfLine">entity_statement_part</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> entity </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>entity</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">entity_header </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>formal</i>_generic_clause</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>formal</i>_port_clause</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">generic_clause </span><span class="PreProc">::=</span>
<span class="Statement">    generic ( </span><span class="bnfLine">generic_list</span><span class="Statement"> ) ;</span>

<span class="Constant">generic_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>generic</i>_interface_list</span>

<span class="Constant">port_clause </span><span class="PreProc">::=</span>
<span class="Statement">    port ( </span><span class="bnfLine">port_list</span><span class="Statement"> ) ;</span>

<span class="Constant">port_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>port</i>_interface_list</span>

<span class="Constant">entity_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">entity_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">entity_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_body</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subtype_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">signal_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">shared_variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">alias_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">disconnection_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_template_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>

<span class="Constant">entity_statement_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">entity_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">entity_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">concurrent_assertion_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>passive</i>_concurrent_procedure_call_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>passive</i>_process_statement</span>


The entity declarative part may be used to declare items which are to be used in the implementation of the entity. Usually such declarations will be included in the implementation itself, so they are only mentioned here for completeness. Also, the optional statements in the entity declaration may be used to define some special behaviour for monitoring operation of the entity. Discussion of these will be deferred until Section6.5.  The entity header is the most important part of the entity declaration. It may include specification of generic constants, which can be used to control the structure and behaviour of the entity, and ports, which channel information into and out of the entity.  The generic constants are specified using an interface list similar to that of a subprogram declaration. All of the items must be of class constant. As a reminder, the syntax of an interface constant declaration is:

<span class="Constant">interface_constant_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> constant </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfOr">[</span><span class="Statement"> in </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine"><i>static</i>_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>


The actual value for each generic constant is passed in when the entity is used as a component in a design.
The entity ports are also specified using an interface list, but the items in the list must all be of class signal. This is a new kind of interface item not previously discussed. The syntax is:

<span class="Constant">interface_signal_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> signal </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">mode</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> bus </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine"><i>static</i>_expression</span><span class="Statement"> </span><span class="bnfOr">]</span>


Since the class must be signal, the word signal can be omitted and is assumed. The word bus may be used if the port is to be connected to more than one output (see Sections 6.1 and 6.2). As with generic constants the actual signals to be connected to the ports are specified when the entity is used as a component in a design.
To clarify this discussion, here are some examples of entity declarations:

    <span class="Statement">entity</span> processor <span class="Statement">is</span>
        <span class="Statement">generic</span> <span class="Special">(</span>max_clock_freq : frequency <span class="Statement">:=</span> <span class="Constant">30</span> MHz<span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            clock : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
            address : <span class="Statement">out</span> <span class="Type">integer</span><span class="Special">;</span>
            data : <span class="Statement">inout</span> word_32<span class="Special">;</span>
            control : <span class="Statement">out</span> proc_control<span class="Special">;</span>
            ready : <span class="Statement">in</span> <span class="Type">bit</span>
        <span class="Special">);</span>
    <span class="Statement">end</span> processor<span class="Special">;</span>


In this case, the generic constant max_clock_freq is used to specify the timing behaviour of the entity. The code describing the entity's behaviour would use this value to determine delays in changing signal values.
Next, an example showing how generic parameters can be used to specify a class of entities with varying structure:

    <span class="Statement">entity</span> ROM <span class="Statement">is</span>
        <span class="Statement">generic</span> <span class="Special">(</span>width<span class="Special">,</span> depth : <span class="Type">positive</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            enable : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
            address : <span class="Statement">in</span> <span class="Type">bit_vector</span><span class="Special">(</span>depth <span class="Statement">-</span> <span class="Constant">1</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
            data : <span class="Statement">out</span> <span class="Type">bit_vector</span><span class="Special">(</span>width <span class="Statement">-</span> <span class="Constant">1</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">)</span>
        <span class="Special">);</span>
    <span class="Statement">end</span> ROM<span class="Special">;</span>


Here, the two generic constants are used to specify the number of data bits and address bits respectively for the read-only memory. Note that no default value is given for either of these constants. This means that when the entity is used as a component, actual values must be supplied for them.
Finally an example of an entity declaration with no generic constants or
ports:

    <span class="Statement">entity</span> test_bench <span class="Statement">is</span>
    <span class="Statement">end</span> test_bench<span class="Special">;</span>


Though this might at first seem to be a pointless example, in fact it illustrates a common use of entities, shown in Figure3-1. A top-level entity for a design under test (DUT) is used as a component in a test bench circuit with another entity (TG) whose purpose is to generate test values. The values on signals can be traced using a simulation monitor, or checked directly by the test generator. No external connections from the test bench are needed, hence it has no ports.

<h3>3.2. Architecture Declarations</h3>
Once an entity has had its interface specified in an entity declaration, one or more implementations of the entity can be described in architecture bodies. Each architecture body can describe a different view of the entity.  For example, one architecture body may purely describe the behaviour using the facilities covered in Chapters 2 and 4, whereas others may describe the structure of the entity as a hierarchically composed collection of components. In this section, we will only cover structural descriptions, deferring behaviour descriptions until Chapter4.
An architecture body is declared using the syntax:

<span class="Constant">architecture_body </span><span class="PreProc">::=</span>
<span class="Statement">    architecture </span><span class="bnfLine">identifier</span><span class="Statement"> of </span><span class="bnfLine">entity_name</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">architecture_declarative_part</span>
<span class="Statement">    begin</span>
<span class="Statement">        </span><span class="bnfLine">architecture_statement_part</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> architecture </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>architecture</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">architecture_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">block_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">block_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_body</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subtype_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">signal_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">shared_variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">alias_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">component_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">configuration_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">disconnection_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_template_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>

<span class="Constant">architecture_statement_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">concurrent_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">concurrent_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">block_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">process_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">concurrent_procedure_call_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">concurrent_assertion_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">concurrent_signal_assignment_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">component_instantiation_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">generate_statement</span>


The declarations in the architecture body define items that will be used to construct the design description. In particular, signals and components may be declared here and used to construct a structural description in terms of component instances, as illustrated in Section1.4. These are discussed in more detail in the next sections.

<h4>3.2.1. Signal Declarations</h4>
Signals are used to connect sub-modules in a design. They are declared using the syntax:

<span class="Constant">signal_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    signal </span><span class="bnfLine">identifier_list</span><span class="Statement"> : </span><span class="bnfLine">subtype_indication</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">signal_kind</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> := </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">signal_kind </span><span class="PreProc">::=</span>
<span class="Statement">    register </span><span class="bnfOr">|</span><span class="Statement"> bus</span>


Use of the signal kind specification is covered in Section6.2. Omitting the signal kind results in an ordinary signal of the subtype specified. The expression in the declaration is used to give the signal an initial value during the initialisation phase of simulation. If the expression is omitted, a default initial value will be assigned.
One important point to note is that ports of an object are treated exactly as signals within that object.

<h4>3.2.2. Blocks</h4>
The sub-modules in an architecture body can be described as blocks. A block is a unit of module structure, with its own interface, connected to other blocks or ports by signals. A block is specified using the syntax:

<span class="Constant">block_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>block</i>_label</span><span class="Statement"> : block </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine"><i>guard</i>_expression</span><span class="Statement"> ) </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> is </span><span class="bnfOr">]</span>
<span class="Statement">        </span><span class="bnfLine">block_header</span>
<span class="Statement">        </span><span class="bnfLine">block_declarative_part</span>
<span class="Statement">    begin</span>
<span class="Statement">        </span><span class="bnfLine">block_statement_part</span>
<span class="Statement">    end block </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>block</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">block_header </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">generic_clause</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">generic_map_aspect</span><span class="Statement"> ; </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">port_clause</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">port_map_aspect</span><span class="Statement"> ; </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">generic_map_aspect </span><span class="PreProc">::=</span>
<span class="Statement">    generic map ( </span><span class="bnfLine"><i>generic</i>_association_list</span><span class="Statement"> )</span>

<span class="Constant">association_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">association_element</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">association_element</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">association_element </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">formal_part</span><span class="Statement"> =&gt; </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">actual_part</span>

<span class="Constant">formal_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">formal_designator</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>function</i>_name</span><span class="Statement"> ( </span><span class="bnfLine">formal_designator</span><span class="Statement"> ) </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ( </span><span class="bnfLine">formal_designator</span><span class="Statement"> )</span>

<span class="Constant">formal_designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>generic</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>port</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>parameter</i>_name</span>

<span class="Constant">actual_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">actual_designator</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>function</i>_name</span><span class="Statement"> ( </span><span class="bnfLine">actual_designator</span><span class="Statement"> ) </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_mark</span><span class="Statement"> ( </span><span class="bnfLine">actual_designator</span><span class="Statement"> )</span>

<span class="Constant">actual_designator </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">expression</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>signal</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>variable</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>file</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    open</span>

<span class="Constant">port_map_aspect </span><span class="PreProc">::=</span>
<span class="Statement">    port map ( </span><span class="bnfLine"><i>port</i>_association_list</span><span class="Statement"> )</span>

<span class="Constant">block_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">block_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">block_statement_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">concurrent_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>


The guard expression is not covered in this booklet, and may be omitted.  The block header defines the interface to the block in much the same way as an entity header defines the interface to an entity. The generic association list specifies values for the generic constants, evaluated in the context of the enclosing block or architecture body. The port map association list specifies which actual signals or ports from the enclosing block or architecture body are connected to the block’s ports. Note that a block statement part may also contain block statements, so a design can be composed of a hierarchy of blocks, with behavioural descriptions at the bottom level of the hierarchy.
As an example, suppose we want to describe a structural architecture of the processor entity example in Section3.1. If we separate the processor into a control unit and a data path section, we can write a description as a pair of interconnected blocks, as shown in Figure3-2.  The control unit block has ports clk, bus_control and bus_ready, which are connected to the processor entity ports. It also has an output port for controlling the data path, which is connected to a signal declared in the architecture. That signal is also connected to a control port on the data path block. The address and data ports of the data path block are connected to the corresponding entity ports. The advantage of this modular decomposition is that each of the blocks can then be developed independently, with the only effects on other blocks being well defined through their interfaces.

    <span class="Statement">architecture</span> block_structure <span class="Statement">of</span> processor <span class="Statement">is</span>
        <span class="Statement">type</span> data_path_control <span class="Statement">is</span> … <span class="Special">;</span>
        <span class="Statement">signal</span> internal_control : data_path_control<span class="Special">;</span>
    <span class="Statement">begin</span>
        control_unit : <span class="Statement">block</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            clk : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
            bus_control : <span class="Statement">out</span> proc_control<span class="Special">;</span>
            bus_ready : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
            control : <span class="Statement">out</span> data_path_control
        <span class="Special">);</span>
        <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>
            clk <span class="Statement">=&gt;</span> clock<span class="Special">,</span>
            bus_control <span class="Statement">=&gt;</span> control<span class="Special">,</span> bus_ready <span class="Statement">=&gt;</span> ready<span class="Special">;</span>
            control <span class="Statement">=&gt;</span> internal_control
        <span class="Special">);</span>
       <span class="Comment"> -- declarations for control_unit</span>
        <span class="Statement">begin</span>
           <span class="Comment"> -- statements for control_unit</span>
        <span class="Statement">end</span> <span class="Statement">block</span> control_unit<span class="Special">;</span>
        data_path : <span class="Statement">block</span>
            <span class="Statement">port</span> <span class="Special">(</span>
                address : <span class="Statement">out</span> <span class="Type">integer</span><span class="Special">;</span>
                data : <span class="Statement">inout</span> word_32<span class="Special">;</span>
                control : <span class="Statement">in</span> data_path_control
            <span class="Special">);</span>
            <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>
                address <span class="Statement">=&gt;</span> address<span class="Special">,</span>
                data <span class="Statement">=&gt;</span> data<span class="Special">,</span>
                control <span class="Statement">=&gt;</span> internal_control
            <span class="Special">);</span>
           <span class="Comment"> -- declarations for data_path</span>
        <span class="Statement">begin</span>
           <span class="Comment"> -- statements for data_path</span>
        <span class="Statement">end</span> <span class="Statement">block</span> data_path<span class="Special">;</span>
    <span class="Statement">end</span> block_structure<span class="Special">;</span>

Figure3-2. Structural architecture of processor example.

<h4>3.2.3. Component Declarations</h4>
An architecture body can also make use of other entities described separately and placed in design libraries. In order to do this, the architecture must declare a component, which can be thought of as a template defining a virtual design entity, to be instantiated within the architecture. Later, a configuration specification (see Section3.3) can be used to specify a matching library entity to use. The syntax of a component declaration is:

<span class="Constant">component_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    component </span><span class="bnfLine">identifier</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> is </span><span class="bnfOr">]</span>
<span class="Statement">        </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>local</i>_generic_clause</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">        </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>local</i>_port_clause</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    end component </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>component</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


Some examples of component declarations:

    <span class="Statement">component</span> nand3
        <span class="Statement">generic</span> <span class="Special">(</span>Tpd : <span class="Type">Time</span> <span class="Statement">:=</span> <span class="Constant">1 ns</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            a<span class="Special">,</span> b<span class="Special">,</span> c : <span class="Statement">in</span> logic_level<span class="Special">;</span>
            y : <span class="Statement">out</span> logic_level
        <span class="Special">);</span>
    <span class="Statement">end</span> <span class="Statement">component</span><span class="Special">;</span>

    <span class="Statement">component</span> read_only_memory
        <span class="Statement">generic</span> <span class="Special">(</span>data_bits<span class="Special">,</span> addr_bits : <span class="Type">positive</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            en : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
            addr : <span class="Statement">in</span> <span class="Type">bit_vector</span><span class="Special">(</span>depth <span class="Statement">-</span> <span class="Constant">1</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
            data : <span class="Statement">out</span> <span class="Type">bit_vector</span><span class="Special">(</span>width <span class="Statement">-</span> <span class="Constant">1</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">)</span>
        <span class="Special">);</span>
    <span class="Statement">end</span> <span class="Statement">component</span><span class="Special">;</span>


The first example declares a three-input gate with a generic parameter specifying its propagation delay. Different instances can later be used with possibly different propagation delays. The second example declares a readonly memory component with address depth and data width dependent on generic constants. This component could act as a template for the ROM entity described in Section3.1.

<h4>3.2.4. Component Instantiation</h4>
A component defined in an architecture may be instantiated using the syntax:

<span class="Constant">component_instantiation_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>instantiation</i>_label</span><span class="Statement"> : </span><span class="bnfLine">instantiated_unit</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">generic_map_aspect</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">port_map_aspect</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">instantiated_unit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> component </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">component_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    entity </span><span class="bnfLine">entity_name</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">architecture_identifier</span><span class="Statement"> ) </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    configuration </span><span class="bnfLine">configuration_name</span>


This indicates that the architecture contains an instance of the named component, with actual values specified for generic constants, and with the component ports connected to actual signals or entity ports.
The example components declared in the previous section might be instantiated as:

    enable_gate: nand3
        <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>a <span class="Statement">=&gt;</span> en1<span class="Special">,</span> b <span class="Statement">=&gt;</span> en2<span class="Special">,</span> c <span class="Statement">=&gt;</span> int_req<span class="Special">,</span> y <span class="Statement">=&gt;</span> interrupt<span class="Special">);</span>

    parameter_rom: read_only_memory
        <span class="Statement">generic</span> <span class="Statement">map</span> <span class="Special">(</span>data_bits <span class="Statement">=&gt;</span> <span class="Constant">16</span><span class="Special">,</span> addr_bits <span class="Statement">=&gt;</span> <span class="Constant">8</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>en <span class="Statement">=&gt;</span> rom_sel<span class="Special">,</span> data <span class="Statement">=&gt;</span> param<span class="Special">,</span> addr <span class="Statement">=&gt;</span> a<span class="Special">(</span><span class="Constant">7</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>


In the first instance, no generic map specification is given, so the default value for the generic constant Tpd is used. In the second instance, values are specified for the address and data port sizes. Note that the actual signal associated with the port addr is a slice of an array signal. This illustrates that a port which is an array can be connected to part of a signal which is a larger array, a very common practice with bus signals.

<h2>4. VHDL Describes Behaviour</h2>
In Section 1.2 we stated that the behaviour of a digital system could be described in terms of programming language notation. The familiar sequential programming language aspects of VHDL were covered in detail in Chapter 2. In this chapter, we describe how these are extended to include statements for modifying values on signals, and means of responding to the changing signal values.

<h3>4.1. Signal Assignment</h3>
A signal assignment schedules one or more transactions to a signal (or port). The syntax of a signal assignment is:

<span class="Constant">signal_assignment_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">target</span><span class="Statement"> &lt;= </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">delay_mechanism</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">waveform</span><span class="Statement"> ;</span>

<span class="Constant">delay_mechanism </span><span class="PreProc">::=</span>
<span class="Statement">    transport </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> reject </span><span class="bnfLine"><i>time</i>_expression</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> inertial</span>

<span class="Constant">waveform </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">waveform_element</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">waveform_element</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    unaffected</span>

<span class="Constant">waveform_element </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>value</i>_expression</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement">after </span><span class="bnfLine"><i>time</i>_expression</span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    null </span><span class="bnfOr">[</span><span class="Statement">after </span><span class="bnfLine"><i>time</i>_expression</span><span class="bnfOr">]</span>


The target must represent a signal, or be an aggregate of signals (see also variable assignments, Section 2.4.1). If the time expression for the delay is omitted, it defaults to 0 fs. This means that the transaction will be scheduled for the same time as the assignment is executed, but during the next simulation cycle.
Each signal has associated with it a projected output waveform, which is a list of transactions giving future values for the signal. A signal assignment adds transactions to this waveform. So, for example, the signal assignment:

    s <span class="Statement">&lt;=</span> <span class="Constant">'0'</span> <span class="Statement">after</span> <span class="Constant">10 ns</span><span class="Special">;</span>


will cause the signal enable to assume the value true 10 ns after the assignment is executed. We can represent the projected output waveform graphically by showing the transactions along a time axis. So if the above assignment were executed at time 5 ns, the projected waveform would be:

    15ns <span class="Statement">/</span> <span class="Constant">'0'</span>


When simulation time reaches 15 ns, this transaction will be processed and the signal updated.
Suppose then at time 16 ns, the assignment:

    s <span class="Statement">&lt;=</span> <span class="Constant">'1'</span> <span class="Statement">after</span> <span class="Constant">4 ns</span><span class="Special">,</span> <span class="Constant">'0'</span> <span class="Statement">after</span> <span class="Constant">20 ns</span><span class="Special">;</span>


were executed. The two new transactions are added to the projected output waveform:

    20ns <span class="Statement">/</span> <span class="Constant">'1'</span>
    36ns <span class="Statement">/</span> <span class="Constant">'0'</span>


Note that when multiple transactions are listed in a signal assignment, the delay times specified must be in ascending order.
If a signal assignment is executed, and there are already old transactions from a previous assignment on the projected output waveform, then some of the old transactions may be deleted. The way this is done depends on whether the word transport is included in the new assignment.  If it is included, the assignment is said to use transport delay. In this case, all old transactions scheduled to occur after the first new transaction are deleted before the new transactions are added. It is as though the new transactions supersede the old ones. So given the projected output waveform shown immediately above, if the assignment:

    s <span class="Statement">&lt;=</span> <span class="Statement">transport</span> <span class="Constant">'Z'</span> <span class="Statement">after</span> <span class="Constant">10 ns</span><span class="Special">;</span>


were executed at time 18 ns, then the transaction scheduled for 36 ns would be deleted, and the projected output waveform would become:

    20ns <span class="Statement">/</span> <span class="Constant">'1'</span>
    28ns <span class="Statement">/</span> <span class="Constant">'Z'</span>


The second kind of delay, inertial delay, is used to model devices which do not respond to input pulses shorter than their output delay. An inertial delay is specified by omitting the word transport from the signal assignment. When an inertial delay transaction is added to a projected output waveform, firstly all old transactions scheduled to occur after the new transaction are deleted, and the new transaction is added, as in the case of transport delay. Next, all old transactions scheduled to occur before the new transaction are examined. If there are any with a different value from the new transaction, then all transactions up to the last one with a different value are deleted. The remaining transactions with the same value are left.
To illustrate this, suppose the projected output waveform at time 0 ns is:

    10ns <span class="Statement">/</span> <span class="Constant">'1'</span>
    15ns <span class="Statement">/</span> <span class="Constant">'0'</span>
    20ns <span class="Statement">/</span> <span class="Constant">'1'</span>
    30ns <span class="Statement">/</span> <span class="Constant">'Z'</span>


and the assignment:

    s <span class="Statement">&lt;=</span> <span class="Constant">'1'</span> <span class="Statement">after</span> <span class="Constant">25 ns</span><span class="Special">;</span>


is executed also at 0 ns. Then the new projected output waveform is:

    20ns <span class="Statement">/</span> <span class="Constant">'1'</span>
    25ns <span class="Statement">/</span> <span class="Constant">'1'</span>


When a signal assignment with multiple waveform elements is specified with inertial delay, only the first transaction uses inertial delay; the rest are treated as being transport delay transactions.

<h3>4.2. Processes and the Wait Statement</h3>
The primary unit of behavioural description in VHDL is the process. A process is a sequential body of code which can be activated in response to changes in state. When more than one process is activated at the same time, they execute concurrently. A process is specified in a process statement, with the syntax:

<span class="Constant">process_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>process</i>_label</span><span class="Statement"> : </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> postponed </span><span class="bnfOr">]</span><span class="Statement"> process </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">sensitivity_list</span><span class="Statement"> ) </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> is </span><span class="bnfOr">]</span>
<span class="Statement">        </span><span class="bnfLine">process_declarative_part</span>
<span class="Statement">    begin</span>
<span class="Statement">        </span><span class="bnfLine">process_statement_part</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> postponed </span><span class="bnfOr">]</span><span class="Statement"> process </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>process</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">sensitivity_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>signal</i>_name</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine"><i>signal</i>_name</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">process_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">process_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">process_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subprogram_body</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">type_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">subtype_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">constant_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">variable_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">file_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">alias_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_template_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>

<span class="Constant">process_statement_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">sequential_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">sequential_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">wait_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">assertion_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">report_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">signal_assignment_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">variable_assignment_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">procedure_call_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">if_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">case_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">loop_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">next_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">exit_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">return_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">null_statement</span>


A process statement is a concurrent statement which can be used in an architecture body or block. The declarations define items which can be used locally within the process. Note that variables may be defined here and used to store state in a model.
A process may contain a number of signal assignment statements for a given signal, which together form a driver for the signal. Normally there may only be one driver for a signal, and so the code which determines a signals value is confined to one process.
A process is activated initially during the initialisation phase of simulation. It executes all of the sequential statements, and then repeats, starting again with the first statement. A process may suspended itself by executing a wait statement. This is of the form:

<span class="Constant">wait_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> wait </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">sensitivity_clause</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">condition_clause</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">timeout_clause</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">sensitivity_clause </span><span class="PreProc">::=</span>
<span class="Statement">    on </span><span class="bnfLine">sensitivity_list</span>

<span class="Constant">condition_clause </span><span class="PreProc">::=</span>
<span class="Statement">    until </span><span class="bnfLine">condition</span>

<span class="Constant">condition </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>boolean</i>_expression</span>

<span class="Constant">timeout_clause </span><span class="PreProc">::=</span>
<span class="Statement">    for </span><span class="bnfLine"><i>time</i>_expression</span>


The sensitivity list of the wait statement specifies a set of signals to which the process is sensitive while it is suspended. When an event occurs on any of these signals (that is, the value of the signal changes), the process resumes and evaluates the condition. If it is true or if the condition is omitted, execution proceeds with the next statement, otherwise the process re-suspends. If the sensitivity clause is omitted, then the process is sensitive to all of the signals mentioned in the condition expression. The timeout expression must evaluate to a positive duration, and indicates the maximum time for which the process will wait. If it is omitted, the process may wait indefinitely.
If a sensitivity list is included in the header of a process statement, then the process is assumed to have an implicit wait statement at the end of its statement part. The sensitivity list of this implicit wait statement is the same as that in the process header. In this case the process may not contain any explicit wait statements.
An example of a process statements with a sensitivity list:

    <span class="Statement">process</span> <span class="Special">(</span>reset<span class="Special">,</span> clock<span class="Special">)</span>
        <span class="Statement">variable</span> state : <span class="Type">bit</span> <span class="Statement">:=</span> <span class="Constant">false</span><span class="Special">;</span>
    <span class="Statement">begin</span>
        <span class="Statement">if</span> reset <span class="Statement">then</span>
            state <span class="Statement">:=</span> <span class="Constant">false</span><span class="Special">;</span>
        <span class="Statement">elsif</span> clock <span class="Statement">=</span> <span class="Constant">true</span> <span class="Statement">then</span>
            state <span class="Statement">:=</span> <span class="Statement">not</span> state<span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">if</span><span class="Special">;</span>
        q <span class="Statement">&lt;=</span> state <span class="Statement">after</span> prop_delay<span class="Special">;</span>
       <span class="Comment"> -- implicit wait on reset, clock</span>
    <span class="Statement">end</span> <span class="Statement">process</span><span class="Special">;</span>


During the initialisation phase of simulation, the process is activated and assigns the initial value of state to the signal q. It then suspends at the implicit wait statement indicated in the comment. When either reset or clock change value, the process is resumed, and execution repeats from the beginning.
The next example describes the behaviour of a synchronisation device called a Muller-C element used to construct asynchronous logic. The output of the device starts at the value '0', and stays at this value until both inputs are '1', at which time the output changes to '1'. The output then stays '1' until both inputs are '0', at which time the output changes back to '0'.

    muller_c_2 : <span class="Statement">process</span>
    <span class="Statement">begin</span>
        <span class="Statement">wait</span> <span class="Statement">until</span> a <span class="Statement">=</span> <span class="Constant">'1'</span> <span class="Statement">and</span> b <span class="Statement">=</span> <span class="Constant">'1'</span><span class="Special">;</span>
        q <span class="Statement">&lt;=</span> <span class="Constant">'1'</span><span class="Special">;</span>
        <span class="Statement">wait</span> <span class="Statement">until</span> a <span class="Statement">=</span> <span class="Constant">'0'</span> <span class="Statement">and</span> b <span class="Statement">=</span> <span class="Constant">'0'</span><span class="Special">;</span>
        q <span class="Statement">&lt;=</span> <span class="Constant">'0'</span><span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">process</span> muller_c_2 <span class="Special">;</span>


This process does not include a sensitivity list, so explicit wait statements are used to control the suspension and activation of the process. In both wait statements, the sensitivity list is the set of signals a and b, determined from the condition expression.

<h3>4.3. Concurrent Signal Assignment Statements</h3>
Often a process describing a driver for a signal contains only one signal assignment statement. VHDL provides a convenient short-hand notation, called a concurrent signal assignment statement, for expressing such processes. The syntax is:

<span class="Constant">concurrent_signal_assignment_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> postponed </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">conditional_signal_assignment</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> postponed </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">selected_signal_assignment</span>


For each kind of concurrent signal assignment, there is a corresponding process statement with the same meaning.

<h4>4.3.1. Conditional Signal Assignment</h4>
A conditional signal assignment statement is a shorthand for a process containing signal assignments in an if statement. The syntax is:

<span class="Constant">conditional_signal_assignment </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">target</span><span class="Statement"> &lt;= </span><span class="bnfLine">options</span><span class="Statement"> </span><span class="bnfLine">conditional_waveforms</span><span class="Statement"> ;</span>

<span class="Constant">options </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> guarded </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">delay_mechanism</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">conditional_waveforms </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">waveform</span><span class="Statement"> when </span><span class="bnfLine">condition</span><span class="Statement"> else </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfLine">waveform</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> when </span><span class="bnfLine">condition</span><span class="Statement"> </span><span class="bnfOr">]</span>


Use of the word guarded is not covered in this booklet. If the word transport is included, then the signal assignments in the equivalent process use transport delay.
Suppose we have a conditional signal assignment:

    s <span class="Statement">&lt;=</span> waveform_1 <span class="Statement">when</span> condition_1 <span class="Statement">else</span>
    waveform_2 <span class="Statement">when</span> condition_2 <span class="Statement">else</span>
    …
    waveform_n<span class="Special">;</span>


Then the equivalent process is:

    <span class="Statement">process</span>
        <span class="Statement">if</span> condition_1 <span class="Statement">then</span>
            s <span class="Statement">&lt;=</span> waveform_1<span class="Special">;</span>
        <span class="Statement">elsif</span> condition_2 <span class="Statement">then</span>
            s <span class="Statement">&lt;=</span> waveform_2<span class="Special">;</span>
        <span class="Statement">elsif</span> …
        <span class="Statement">else</span>
            s <span class="Statement">&lt;=</span> waveform_n<span class="Special">;</span>
        <span class="Statement">wait</span> [ sensitivity_clause ]<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">process</span><span class="Special">;</span>


If none of the waveform value expressions or conditions contains a reference to a signal, then the wait statement at the end of the equivalent process has no sensitivity clause. This means that after the assignment is made, the process suspends indefinitely. For example, the conditional assignment:

    reset <span class="Statement">&lt;=</span>
        <span class="Constant">'1'</span><span class="Special">,</span> <span class="Constant">'0'</span> <span class="Statement">after</span> <span class="Constant">10 ns</span> <span class="Statement">when</span> short_pulse_required <span class="Statement">else</span>
        <span class="Constant">'1'</span><span class="Special">,</span> <span class="Constant">'0'</span> <span class="Statement">after</span> <span class="Constant">50 ns</span><span class="Special">;</span>


schedules two transactions on the signal reset, then suspends for the rest of the simulation.
On the other hand, if there are references to signals in the waveform value expressions or conditions, then the wait statement has a sensitivity list consisting of all of the signals referenced. So the conditional assignment:

    mux_out <span class="Statement">&lt;=</span>
        <span class="Constant">'Z'</span> <span class="Statement">after</span> Tpd <span class="Statement">when</span> en <span class="Statement">=</span> <span class="Constant">'0'</span> <span class="Statement">else</span>
        in_0 <span class="Statement">after</span> Tpd <span class="Statement">when</span> sel <span class="Statement">=</span> <span class="Constant">'0'</span> <span class="Statement">else</span>
        in_1 <span class="Statement">after</span> Tpd<span class="Special">;</span>


is sensitive to the signals en and sel. The process is activated during the initialisation phase, and thereafter whenever either of en or sel changes value.
The degenerate case of a conditional signal assignment, containing no conditional parts, is equivalent to a process containing just a signal assignment statement. So:

    s <span class="Statement">&lt;=</span> waveform<span class="Special">;</span>


is equivalent to:

    <span class="Statement">process</span>
        s <span class="Statement">&lt;=</span> waveform<span class="Special">;</span>
        <span class="Statement">wait</span> [ sensitivity_clause ]<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">process</span><span class="Special">;</span>


<h4>4.3.2. Selected Signal Assignment</h4>
A selected signal assignment statement is a shorthand for a process containing signal assignments in a case statement. The syntax is:

<span class="Constant">selected_signal_assignment </span><span class="PreProc">::=</span>
<span class="Statement">    with </span><span class="bnfLine">expression</span><span class="Statement"> select</span>
<span class="Statement">    </span><span class="bnfLine">target</span><span class="Statement"> &lt;= </span><span class="bnfLine">options</span><span class="Statement"> </span><span class="bnfLine">selected_waveforms</span><span class="Statement"> ;</span>

<span class="Constant">selected_waveforms </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">waveform</span><span class="Statement"> when </span><span class="bnfLine">choices</span><span class="Statement"> , </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfLine">waveform</span><span class="Statement"> when </span><span class="bnfLine">choices</span>


The options part is the same as for a conditional signal assignment. So if the word transport is included, then the signal assignments in the equivalent process use transport delay.
Suppose we have a selected signal assignment:

    <span class="Statement">with</span> expression <span class="Statement">select</span>
        s <span class="Statement">&lt;=</span>
            waveform_1 <span class="Statement">when</span> choice_list_1<span class="Special">,</span>
            waveform_2 <span class="Statement">when</span> choice_list_2<span class="Special">,</span>
            …
            waveform_n <span class="Statement">when</span> choice_list_n<span class="Special">;</span>


Then the equivalent process is:

    <span class="Statement">process</span>
        <span class="Statement">case</span> expression <span class="Statement">is</span>
            <span class="Statement">when</span> choice_list_1 <span class="Statement">=&gt;</span> s <span class="Statement">&lt;=</span> waveform_1<span class="Special">;</span>
            <span class="Statement">when</span> choice_list_2 <span class="Statement">=&gt;</span> s <span class="Statement">&lt;=</span> waveform_2<span class="Special">;</span>
            …
            <span class="Statement">when</span> choice_list_n <span class="Statement">=&gt;</span> s <span class="Statement">&lt;=</span> waveform_n<span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">case</span><span class="Special">;</span>
        <span class="Statement">wait</span> [ sensitivity_clause ]<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">process</span><span class="Special">;</span>


The sensitivity list for the wait statement is determined in the same way as for a conditional signal assignment. That is, if no signals are referenced in the selected signal assignment expression or waveforms, the wait statement has no sensitivity clause. Otherwise the sensitivity clause contains all the signals referenced in the expression and waveforms.
An example of a selected signal assignment statement:

    <span class="Statement">with</span> alu_function <span class="Statement">select</span>
        alu_result <span class="Statement">&lt;=</span>
            op1 <span class="Statement">+</span> op2 <span class="Statement">when</span> alu_add | alu_incr<span class="Special">,</span>
            op1 <span class="Statement">-</span> op2 <span class="Statement">when</span> alu_subtract<span class="Special">,</span>
            op1 <span class="Statement">and</span> op2 <span class="Statement">when</span> alu_and<span class="Special">,</span>
            op1 <span class="Statement">or</span> op2 <span class="Statement">when</span> alu_or<span class="Special">,</span>
            op1 <span class="Statement">and</span> <span class="Statement">not</span> op2 <span class="Statement">when</span> alu_mask<span class="Special">;</span>


In this example, the value of the signal alu_function is used to select which signal assignment to alu_result to execute. The statement is sensitive to the signals alu_function, op1 and op2, so whenever any of these change value, the selected signal assignment is resumed.

<h2>5. Model Organisation</h2>
The previous chapters have described the various facilities of VHDL somewhat in isolation. The purpose of this chapter is to show how they are all tied together to form a complete VHDL description of a digital system.

<h3>5.1. Design Units and Libraries</h3>
When you write VHDL descriptions, you write them in a design file, then invoke a compiler to analyse them and insert them into a design library. A number of VHDL constructs may be separately analysed for inclusion in a design library. These constructs are called library units.  The primary library units are entity declarations, package declarations and configuration declarations (see Section 5.2). The secondary library units are architecture bodies and package bodies. These library units depend on the specification of their interface in a corresponding primary library unit, so the primary unit must be analysed before any corresponding secondary unit.
A design file may contain a number of library units. The structure of a design file can be specified by the syntax:

<span class="Constant">design_file </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">design_unit</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">design_unit</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">design_unit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">context_clause</span><span class="Statement"> </span><span class="bnfLine">library_unit</span>

<span class="Constant">context_clause </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">context_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">context_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">library_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span>

<span class="Constant">library_clause </span><span class="PreProc">::=</span>
<span class="Statement">    library </span><span class="bnfLine">logical_name_list</span><span class="Statement"> ;</span>

<span class="Constant">logical_name_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">logical_name</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine">logical_name</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">logical_name </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">identifier</span>

<span class="Constant">library_unit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">primary_unit</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">secondary_unit</span>

<span class="Constant">primary_unit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">entity_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">configuration_declaration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">package_declaration</span>

<span class="Constant">secondary_unit </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">architecture_body</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">package_body</span>


Libraries are referred to using identifiers called logical names. This name must be translated by the host operating system into an implementation dependent storage name. For example, design libraries may be implemented as database files, and the logical name might be used to determine the database file name. Library units in a given library can be referred to by prefixing their name with the library logical name. So for example, ttl_lib.ttl_10 would refer to the unit ttl_10 in library ttl_lib.
The context clause preceding each library unit specifies which other libraries it references and which packages it uses. The scope of the names made visible by the context clause extends until the end of the design unit.
There are two special libraries which are implicitly available to all design units, and so do not need to be named in a library clause. The first of these is called work, and refers to the working design library into which the current design units will be placed by the analyser. Hence in a design unit, the previously analysed design units in a design file can be referred to using the library name work.
The second special library is called std, and contains the packages standard and textio. Standard contains all of the predefined types and functions. All of the items in this package are implicitly visible, so no use clause is necessary to access them.

<h3>5.2. Configurations</h3>
In Sections 3.2.3 and 3.2.4 we showed how a structural description can declare a component specification and create instances of components. We mentioned that a component declared can be thought of as a template for a design entity. The binding of an entity to this template is achieved through a configuration declaration. This declaration can also be used to specify actual generic constants for components and blocks. So the configuration declaration plays a pivotal role in organising a design description in preparation for simulation or other processing.
The syntax of a configuration declaration is:

<span class="Constant">configuration_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    configuration </span><span class="bnfLine">identifier</span><span class="Statement"> of </span><span class="bnfLine"><i>entity</i>_name</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">configuration_declarative_part</span>
<span class="Statement">        </span><span class="bnfLine">block_configuration</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> configuration </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>configuration</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">configuration_declarative_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">configuration_declarative_item</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">configuration_declarative_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">attribute_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">group_declaration</span>

<span class="Constant">block_configuration </span><span class="PreProc">::=</span>
<span class="Statement">    for </span><span class="bnfLine">block_specification</span>
<span class="Statement">        </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">use_clause</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">        </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">configuration_item</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">    end for ;</span>

<span class="Constant">block_specification </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>architecture</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>block_statement</i>_label</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>generate_statement</i>_label</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine">index_specification</span><span class="Statement"> ) </span><span class="bnfOr">]</span>

<span class="Constant">index_specification </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">discrete_range</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>static</i>_expression</span>

<span class="Constant">configuration_item </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">block_configuration</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine">component_configuration</span>

<span class="Constant">component_configuration </span><span class="PreProc">::=</span>
<span class="Statement">    for </span><span class="bnfLine">component_specification</span>
<span class="Statement">        </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">binding_indication</span><span class="Statement"> ; </span><span class="bnfOr">]</span>
<span class="Statement">        </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">block_configuration</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    end for ;</span>

<span class="Constant">component_specification </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">instantiation_list</span><span class="Statement"> : </span><span class="bnfLine"><i>component</i>_name</span>

<span class="Constant">instantiation_list </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>instantiation</i>_label</span><span class="Statement"> </span><span class="bnfOr">{</span><span class="Statement"> , </span><span class="bnfLine"><i>instantiation</i>_label</span><span class="Statement"> </span><span class="bnfOr">}</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    others </span><span class="bnfOr">|</span>
<span class="Statement">    all</span>

<span class="Constant">binding_indication </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> use </span><span class="bnfLine">entity_aspect</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">generic_map_aspect</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">port_map_aspect</span><span class="Statement"> </span><span class="bnfOr">]</span>

<span class="Constant">entity_aspect </span><span class="PreProc">::=</span>
<span class="Statement">    entity </span><span class="bnfLine"><i>entity</i>_name</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> ( </span><span class="bnfLine"><i>architecture</i>_identifier</span><span class="Statement">) </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    configuration </span><span class="bnfLine"><i>configuration</i>_name</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    open</span>


The declarative part of the configuration declaration allows the configuration to use items from libraries and packages. The outermost block configuration in the configuration declaration defines the configuration for an architecture of the named entity. For example, in Chapter 3 we had an example of a processor entity and architecture, outlined again in Figure5-1.

    <span class="Statement">entity</span> processor <span class="Statement">is</span>
        <span class="Statement">generic</span> <span class="Special">(</span>max_clock_speed : frequency <span class="Statement">:=</span> <span class="Constant">30</span> MHz<span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span> <span class="Statement">port</span> list <span class="Special">);</span>
    <span class="Statement">end</span> processor<span class="Special">;</span>
    <span class="Statement">architecture</span> block_structure <span class="Statement">of</span> processor <span class="Statement">is</span>
       <span class="Comment"> -- declarations</span>
    <span class="Statement">begin</span>
        control_unit : <span class="Statement">block</span>
            <span class="Statement">port</span> <span class="Special">(</span> <span class="Statement">port</span> list <span class="Special">);</span>
            <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span> association list <span class="Special">);</span>
            declarations <span class="Statement">for</span> control_unit
        <span class="Statement">begin</span>
           <span class="Comment"> -- statements for control_unit</span>
        <span class="Statement">end</span> <span class="Statement">block</span> control_unit<span class="Special">;</span>

        data_path : <span class="Statement">block</span>
            <span class="Statement">port</span> <span class="Special">(</span> <span class="Statement">port</span> list <span class="Special">);</span>
            <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span> association list <span class="Special">);</span>
           <span class="Comment"> -- declarations for data_path</span>
        <span class="Statement">begin</span>
           <span class="Comment"> -- statements for data_path</span>
        <span class="Statement">end</span> <span class="Statement">block</span> data_path<span class="Special">;</span>
    <span class="Statement">end</span> block_structure<span class="Special">;</span>

Figure 5-1. Example processor entity and architecture body.

The overall structure of a configuration declaration for this architecture might be:

    <span class="Statement">configuration</span> test_config <span class="Statement">of</span> processor <span class="Statement">is</span>
        <span class="Statement">use</span> work<span class="Special">.</span>processor_types<span class="Special">.</span><span class="Statement">all</span>
        <span class="Statement">for</span> block_structure
            <span class="Comment"> -- configuration items</span>
        <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
    <span class="Statement">end</span> test_config<span class="Special">;</span>


In this example, the contents of a package called processor_types in the current working library are made visible, and the block configuration refers to the architecture block_structure of the entity processor.
Within the block configuration for the architecture, the sub-modules of the architecture may be configured. These sub-modules include blocks and component instances. A block is configured with a nested block configuration. For example, the blocks in the above architecture can be configured as shown in Figure5-2.

    <span class="Statement">configuration</span> test_config <span class="Statement">of</span> processor <span class="Statement">is</span>
        <span class="Statement">use</span> work<span class="Special">.</span>processor_types<span class="Special">.</span><span class="Statement">all</span>
        <span class="Statement">for</span> block_structure
            <span class="Statement">for</span> control_unit
               <span class="Comment"> -- configuration items</span>
            <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
            <span class="Statement">for</span> data_path
               <span class="Comment"> -- configuration items</span>
            <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
    <span class="Statement">end</span> test_config<span class="Special">;</span>

Figure5-2. Configuration of processor example.

Where a sub-module is an instance of a component, a component configuration is used to bind an entity to the component instance. To illustrate, suppose the data_path block in the above example contained an instance of the component alu, declared as shown in Figure5-3.

    data_path : <span class="Statement">block</span>
        <span class="Statement">port</span> <span class="Special">(</span> <span class="Statement">port</span> list <span class="Special">);</span>
        <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span> association list <span class="Special">);</span>
        <span class="Statement">component</span> alu
            <span class="Statement">port</span> <span class="Special">(</span>
                <span class="Statement">function</span> : <span class="Statement">in</span> alu_function<span class="Special">;</span>
                op1<span class="Special">,</span> op2 : <span class="Statement">in</span> bit_vector_32<span class="Special">;</span>
                result : <span class="Statement">out</span> bit_vector_32
        <span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">component</span><span class="Special">;</span>
       <span class="Comment"> -- other declarations for data_path</span>
    <span class="Statement">begin</span>
        data_alu : alu
        <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span><span class="Statement">function</span> <span class="Statement">=&gt;</span> alu_fn<span class="Special">,</span> op1 <span class="Statement">=&gt;</span> b1<span class="Special">,</span> op2 <span class="Statement">=&gt;</span> b2<span class="Special">,</span> result <span class="Statement">=&gt;</span> alu_r<span class="Special">);</span>
       <span class="Comment"> -- other statements for data_path</span>
    <span class="Statement">end</span> <span class="Statement">block</span> data_path<span class="Special">;</span>

Figure5-3. Structure of processor data-path block.

Suppose also that a library project_cells contains an entity called alu_cell defined as:

    <span class="Statement">entity</span> alu_cell <span class="Statement">is</span>
        <span class="Statement">generic</span> <span class="Special">(</span>width : <span class="Type">positive</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            function_code : <span class="Statement">in</span> alu_function<span class="Special">;</span>
            operand1<span class="Special">,</span> operand2 : <span class="Statement">in</span> <span class="Type">bit_vector</span><span class="Special">(</span>width <span class="Statement">-</span> <span class="Constant">1</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
            result : <span class="Statement">out</span> <span class="Type">bit_vector</span><span class="Special">(</span>width <span class="Statement">-</span> <span class="Constant">1</span> <span class="Statement">downto</span> <span class="Constant">0</span><span class="Special">);</span>
            flags : <span class="Statement">out</span> alu_flags
        <span class="Special">);</span>
    <span class="Statement">end</span> alu_cell<span class="Special">;</span>


with an architecture called behaviour. This entity matches the alu component template, since its operand and result ports can be constrained to match those of the component, and the flags port can be left unconnected.  A block configuration for data_path could be specified as shown in Figure5-4.

    <span class="Statement">for</span> data_path
        <span class="Statement">for</span> data_alu : alu
            <span class="Statement">use</span> <span class="Statement">entity</span> project_cells<span class="Special">.</span>alu_cell<span class="Special">(</span>behaviour<span class="Special">)</span>
            <span class="Statement">generic</span> <span class="Statement">map</span> <span class="Special">(</span>width <span class="Statement">=&gt;</span> <span class="Constant">32</span><span class="Special">)</span>
            <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>
                function_code <span class="Statement">=&gt;</span> <span class="Statement">function</span><span class="Special">,</span>
                operand1 <span class="Statement">=&gt;</span> op1<span class="Special">,</span>
                operand2 <span class="Statement">=&gt;</span> op2<span class="Special">,</span>
                result <span class="Statement">=&gt;</span> result<span class="Special">,</span>
                flags <span class="Statement">=&gt;</span> <span class="Statement">open</span>
            <span class="Special">);</span>
            <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
       <span class="Comment"> -- other configuration items</span>
    <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>

Figure5-4. Block configuration using library entity.

Alternatively, if the library also contained a configuration called alu_struct for an architecture structure of the entity alu_cell, then the block configuration could use this, as shown in Figure5-5.

    <span class="Statement">for</span> data_path
        <span class="Statement">for</span> data_alu : alu
            <span class="Statement">use</span> <span class="Statement">configuration</span> project_cells<span class="Special">.</span>alu_struct
            <span class="Statement">generic</span> <span class="Statement">map</span> <span class="Special">(</span>width <span class="Statement">=&gt;</span> <span class="Constant">32</span><span class="Special">)</span>
            <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>
                function_code <span class="Statement">=&gt;</span> <span class="Statement">function</span><span class="Special">,</span>
                operand1 <span class="Statement">=&gt;</span> op1<span class="Special">,</span>
                operand2 <span class="Statement">=&gt;</span> op2<span class="Special">,</span>
                result <span class="Statement">=&gt;</span> result<span class="Special">,</span>
                flags <span class="Statement">=&gt;</span> <span class="Statement">open</span>
            <span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
       <span class="Comment"> -- other configuration items</span>
    <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>

Figure5-5. Block configuration using another configuration.

<h3>5.3. Complete Design Example</h3>
To illustrate the overall structure of a design description, a complete design file for the example in Section1.4 is shown in Figure5-6. The design file contains a number of design units which are analysed in order. The first design unit is the entity declaration of count2. Following it are two secondary units, architectures of the count2 entity. These must follow the entity declaration, as they are dependent on it. Next is another entity declaration, this being a test bench for the counter. It is followed by a secondary unit dependent on it, a structural description of the test bench.  Following this is a configuration declaration for the test bench. It refers to the previously defined library units in the working library, so no library clause is needed. Notice that the count2 entity is referred to in the configuration as work.count2, using the library name. Lastly, there is a configuration declaration for the test bench using the structural architecture of count2. It uses two library units from a separate reference library, misc. Hence a library clause is included before the configuration declaration. The library units from this library are referred to in the configuration as misc.t_flipflop and misc.inverter.
This design description includes all of the design units in one file. It is equally possible to separate them into a number of files, with the opposite extreme being one design unit per file. If multiple files are used, you need to take care that you compile the files in the correct order, and re-compile dependent files if changes are made to one design unit. Source code control systems can be of use in automating this process.

   <span class="Comment"> -- primary unit: entity declaration of count2</span>
    <span class="Statement">entity</span> count2 <span class="Statement">is</span>
        <span class="Statement">generic</span> <span class="Special">(</span>prop_delay : <span class="Type">Time</span> <span class="Statement">:=</span> <span class="Constant">10 ns</span><span class="Special">);</span>
        <span class="Statement">port</span> <span class="Special">(</span>
            clock : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
            q1<span class="Special">,</span> q0 : <span class="Statement">out</span> <span class="Type">bit</span>
        <span class="Special">);</span>
    <span class="Statement">end</span> count2<span class="Special">;</span>

   <span class="Comment"> -- secondary unit: a behavioural architecture body of count2</span>
    <span class="Statement">architecture</span> behaviour <span class="Statement">of</span> count2 <span class="Statement">is</span>
    <span class="Statement">begin</span>
        count_up: <span class="Statement">process</span> <span class="Special">(</span>clock<span class="Special">)</span>
        <span class="Statement">variable</span> count_value : <span class="Type">natural</span> <span class="Statement">:=</span> <span class="Constant">0</span><span class="Special">;</span>
        <span class="Statement">begin</span>
            <span class="Statement">if</span> clock <span class="Statement">=</span> <span class="Constant">'1'</span> <span class="Statement">then</span>
                count_value <span class="Statement">:=</span> <span class="Special">(</span>count_value <span class="Statement">+</span> <span class="Constant">1</span><span class="Special">)</span> <span class="Statement">mod</span> <span class="Constant">4</span><span class="Special">;</span>
                q0 <span class="Statement">&lt;=</span> <span class="Type">bit'</span>val<span class="Special">(</span>count_value <span class="Statement">mod</span> <span class="Constant">2</span><span class="Special">)</span> <span class="Statement">after</span> prop_delay<span class="Special">;</span>
                q1 <span class="Statement">&lt;=</span> <span class="Type">bit'</span>val<span class="Special">(</span>count_value <span class="Statement">/</span> <span class="Constant">2</span><span class="Special">)</span> <span class="Statement">after</span> prop_delay<span class="Special">;</span>
            <span class="Statement">end</span> <span class="Statement">if</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">process</span> count_up<span class="Special">;</span>
    <span class="Statement">end</span> behaviour<span class="Special">;</span>

   <span class="Comment"> -- secondary unit: a structural architecture body of count2</span>
    <span class="Statement">architecture</span> structure <span class="Statement">of</span> count2 <span class="Statement">is</span>
        <span class="Statement">component</span> t_flipflop
            <span class="Statement">port</span> <span class="Special">(</span>ck : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span> q : <span class="Statement">out</span> <span class="Type">bit</span><span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">component</span><span class="Special">;</span>
        <span class="Statement">component</span> inverter
            <span class="Statement">port</span> <span class="Special">(</span>a : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span> y : <span class="Statement">out</span> <span class="Type">bit</span><span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">component</span><span class="Special">;</span>
        <span class="Statement">signal</span> ff0<span class="Special">,</span> ff1<span class="Special">,</span> inv_ff0 : <span class="Type">bit</span><span class="Special">;</span>
    <span class="Statement">begin</span>
        bit_0 : t_flipflop <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>ck <span class="Statement">=&gt;</span> clock<span class="Special">,</span> q <span class="Statement">=&gt;</span> ff0<span class="Special">);</span>
        inv : inverter <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>a <span class="Statement">=&gt;</span> ff0<span class="Special">,</span> y <span class="Statement">=&gt;</span> inv_ff0<span class="Special">);</span>
        bit_1 : t_flipflop <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>ck <span class="Statement">=&gt;</span> inv_ff0<span class="Special">,</span> q <span class="Statement">=&gt;</span> ff1<span class="Special">);</span>
        q0 <span class="Statement">&lt;=</span> ff0<span class="Special">;</span>
        q1 <span class="Statement">&lt;=</span> ff1<span class="Special">;</span>
    <span class="Statement">end</span> structure<span class="Special">;</span>

   <span class="Comment"> -- primary unit: entity declaration of test bench</span>
    <span class="Statement">entity</span> test_count2 <span class="Statement">is</span>
    <span class="Statement">end</span> test_count2<span class="Special">;</span>

   <span class="Comment"> -- secondary unit: structural architecture body of test bench</span>
    <span class="Statement">architecture</span> structure <span class="Statement">of</span> test_count2 <span class="Statement">is</span>
        <span class="Statement">signal</span> clock<span class="Special">,</span> q0<span class="Special">,</span> q1 : <span class="Type">bit</span><span class="Special">;</span>
        <span class="Statement">component</span> count2
            <span class="Statement">port</span> <span class="Special">(</span>
                clock : <span class="Statement">in</span> <span class="Type">bit</span><span class="Special">;</span>
                q1<span class="Special">,</span> q0 : <span class="Statement">out</span> <span class="Type">bit</span>
            <span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">component</span><span class="Special">;</span>
    <span class="Statement">begin</span>
        counter : count2
            <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>clock <span class="Statement">=&gt;</span> clock<span class="Special">,</span> q0 <span class="Statement">=&gt;</span> q0<span class="Special">,</span> q1 <span class="Statement">=&gt;</span> q1<span class="Special">);</span>
        clock_driver : <span class="Statement">process</span>
        <span class="Statement">begin</span>
            clock <span class="Statement">&lt;=</span> <span class="Constant">'0'</span><span class="Special">,</span> <span class="Constant">'1'</span> <span class="Statement">after</span> <span class="Constant">50 ns</span><span class="Special">;</span>
            <span class="Statement">wait</span> <span class="Statement">for</span> <span class="Constant">100 ns</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">process</span> clock_driver<span class="Special">;</span>
    <span class="Statement">end</span> structure<span class="Special">;</span>

   <span class="Comment"> -- primary unit: configuration using behavioural architecture</span>
    <span class="Statement">configuration</span> test_count2_behaviour <span class="Statement">of</span> test_count2 <span class="Statement">is</span>
        <span class="Statement">for</span> structure<span class="Comment"> -- of test_count2</span>
            <span class="Statement">for</span> counter : count2
                <span class="Statement">use</span> <span class="Statement">entity</span> work<span class="Special">.</span>count2<span class="Special">(</span>behaviour<span class="Special">);</span>
            <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
    <span class="Statement">end</span> test_count2_behaviour<span class="Special">;</span>

   <span class="Comment"> -- primary unit: configuration using structural architecture</span>
    <span class="Statement">library</span> misc<span class="Special">;</span>
    <span class="Statement">configuration</span> test_count2_structure <span class="Statement">of</span> test_count2 <span class="Statement">is</span>
        <span class="Statement">for</span> structure<span class="Comment"> -- of test_count2</span>
            <span class="Statement">for</span> counter : count2
                <span class="Statement">use</span> <span class="Statement">entity</span> work<span class="Special">.</span>count2<span class="Special">(</span>structure<span class="Special">);</span>
                <span class="Statement">for</span> structure<span class="Comment"> -- of count_2</span>
                    <span class="Statement">for</span> <span class="Statement">all</span> : t_flipflop
                        <span class="Statement">use</span> <span class="Statement">entity</span> misc<span class="Special">.</span>t_flipflop<span class="Special">(</span>behaviour<span class="Special">);</span>
                    <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
                    <span class="Statement">for</span> <span class="Statement">all</span> : inverter
                        <span class="Statement">use</span> <span class="Statement">entity</span> misc<span class="Special">.</span>inverter<span class="Special">(</span>behaviour<span class="Special">);</span>
                    <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
                <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
            <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">for</span><span class="Special">;</span>
    <span class="Statement">end</span> test_count2_structure<span class="Special">;</span>

Figure5-6. Complete design file.

<h2>6. Advanced VHDL</h2>
This chapter describes some more advanced facilities offered in VHDL.  Although you can write many models using just the parts of the language covered in the previous chapters, you will find the features described here will significantly extend your model writing abilities.

<h3>6.1. Signal Resolution and Buses</h3>
In many digital systems, buses are used to connect a number of output drivers to a common signal. For example, if open-collector or open-drain output drivers are used with a pull-up load on a signal, the signal can be pulled low by any driver, and is only pulled high by the load when all drivers are off. This is called a wired-or or wired-and connection. On the other hand, if tri-state drivers are used, at most one driver may be active at a time, and it determines the signal value.
VHDL normally allows only one driver for a signal. (Recall that a driver is defined by the signal assignments in a process.) In order to model signals with multiple drivers, VHDL uses the notion of resolved types for signals. A resolved type includes in its definition a resolution function, which takes the values of all the drivers contributing to a signal, and combines them to determine the final signal value.
A resolved type for a signal is declared using the syntax for a subtype:

<span class="Constant">subtype_indication </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>resolution_function</i>_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">type_mark</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">constraint</span><span class="Statement"> </span><span class="bnfOr">]</span>


The resolution function name is the name of a function previously defined.  The function must take a parameter which is an unconstrained array of values of the signal subtype, and must return a result of that subtype. To illustrate, consider the declarations:

    <span class="Statement">type</span> logic_level <span class="Statement">is</span> <span class="Special">(</span>L<span class="Special">,</span> Z<span class="Special">,</span> H<span class="Special">);</span>
    <span class="Statement">type</span> logic_array <span class="Statement">is</span> <span class="Statement">array</span> <span class="Special">(</span><span class="Type">integer</span> <span class="Statement">range</span> <span class="Special">&lt;&gt;)</span> <span class="Statement">of</span> logic_level<span class="Special">;</span>
    <span class="Statement">function</span> resolve_logic <span class="Special">(</span>drivers : <span class="Statement">in</span> logic_array<span class="Special">)</span> <span class="Statement">return</span> logic_level<span class="Special">;</span>
    <span class="Statement">subtype</span> resolved_level <span class="Statement">is</span> resolve_logic logic_level<span class="Special">;</span>


In this example, the type logic_level represents three possible states for a digital signal: low (L), high-impedance (Z) and high (H). The subtype resolved_level can be used to declare a resolved signal of this type. The resolution function might be implemented as shown in Figure6-1.

    <span class="Statement">function</span> resolve_logic <span class="Special">(</span>drivers : <span class="Statement">in</span> logic_array<span class="Special">)</span> <span class="Statement">return</span> logic_level<span class="Special">;</span>
    <span class="Statement">begin</span>
        <span class="Statement">for</span> index <span class="Statement">in</span> drivers<span class="Special">'range</span> <span class="Statement">loop</span>
            <span class="Statement">if</span> drivers<span class="Special">(</span>index<span class="Special">)</span> <span class="Statement">=</span> L <span class="Statement">then</span>
                <span class="Statement">return</span> L<span class="Special">;</span>
            <span class="Statement">end</span> <span class="Statement">if</span><span class="Special">;</span>
        <span class="Statement">end</span> <span class="Statement">loop</span><span class="Special">;</span>
        <span class="Statement">return</span> H<span class="Special">;</span>
    <span class="Statement">end</span> resolve_logic<span class="Special">;</span>

Figure 6-1. Resolution function for three-state logic

This function iterates over the array of drivers, and if any is found to have the value L, the function returns L. Otherwise the function returns H, since all drivers are either Z or H. This models a wired-or signal with a pull-up.  Note that in some cases a resolution function may be called with an empty array as the parameter, and should handle that case appropriately. The example above handles it by returning the value H, the pulled-up value.

<h3>6.2.  Null Transactions</h3>
VHDL provides a facility to model outputs which may be turned off (for example tri-state drivers). A signal assignment may specify that no value is to be assigned to a resolved signal, that is, that the driver should be disconnected. This is done with a null waveform element. Recall that the syntax for a waveform element is:

<span class="Constant">waveform_element </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>value</i>_expression</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement">after </span><span class="bnfLine"><i>time</i>_expression</span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    null </span><span class="bnfOr">[</span><span class="Statement">after </span><span class="bnfLine"><i>time</i>_expression</span><span class="bnfOr">]</span>


So an example of such a signal assignment is:

    d_out <span class="Statement">&lt;=</span> <span class="Statement">null</span> <span class="Statement">after</span> Toz<span class="Special">;</span>


If all of the drivers of a resolved signal are disconnected, the question of the resulting signal value arises. There are two possibilities, depending on whether the signal was declared with signal kind register or bus. For register kind signals, the most recently determined value remains on the signal. This can be used to model charge storage nodes in MOS logic families. For bus kind signals, the resolution function must determine the value for the signal when no drivers are contributing to it. This is how tri-state, open-collector and open-drain buses would typically be modelled.

<h3>6.3. Generate Statements</h3>
VHDL has an additional concurrent statement which can be used in architecture bodies to describe regular structures, such as arrays of blocks, component instances or processes. The syntax is:

<span class="Constant">generate_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine"><i>generate</i>_label</span><span class="Statement"> : </span><span class="bnfLine">generation_scheme</span><span class="Statement"> generate</span>
<span class="Statement">        </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">{</span><span class="Statement"> </span><span class="bnfLine">block_declarative_item</span><span class="Statement"> </span><span class="bnfLine">}</span>
<span class="Statement">    begin </span><span class="bnfOr">]</span>
<span class="Statement">        </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">concurrent_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>
<span class="Statement">    end generate </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>generate</i>_label</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>

<span class="Constant">generation_scheme </span><span class="PreProc">::=</span>
<span class="Statement">    for </span><span class="bnfLine"><i>generate</i>_parameter_specification</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    if </span><span class="bnfLine">condition</span>


The for generation scheme describes structures which have a repeating pattern. The if generation scheme is usually used to handle exception cases within the structure, such as occur at the boundaries. This is best illustrated by example. Suppose we want to describe the structure of an adder constructed out of full-adder cells, with the exception of the least significant bit, which is consists of a half-adder. A generate statement to achieve this is shown in Figure6-2.

    adder : <span class="Statement">for</span> i <span class="Statement">in</span> <span class="Constant">0</span> <span class="Statement">to</span> width<span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">generate</span>
        ls_bit : <span class="Statement">if</span> i <span class="Statement">=</span> <span class="Constant">0</span> <span class="Statement">generate</span>
            ls_cell : half_adder
                <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>a<span class="Special">(</span><span class="Constant">0</span><span class="Special">),</span> b<span class="Special">(</span><span class="Constant">0</span><span class="Special">),</span> sum<span class="Special">(</span><span class="Constant">0</span><span class="Special">),</span> c_in<span class="Special">(</span><span class="Constant">1</span><span class="Special">));</span>
        <span class="Statement">end</span> <span class="Statement">generate</span> lsbit<span class="Special">;</span>

        middle_bit : <span class="Statement">if</span> i <span class="Statement">&gt;</span> <span class="Constant">0</span> <span class="Statement">and</span> i <span class="Statement">&lt;</span> width<span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">generate</span>
            middle_cell : full_adder
                <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>a<span class="Special">(</span>i<span class="Special">),</span> b<span class="Special">(</span>i<span class="Special">),</span> c_in<span class="Special">(</span>i<span class="Special">),</span> sum<span class="Special">(</span>i<span class="Special">),</span> c_in<span class="Special">(</span>i<span class="Statement">+</span><span class="Constant">1</span><span class="Special">));</span>
        <span class="Statement">end</span> <span class="Statement">generate</span> middle_bit<span class="Special">;</span>

        ms_bit : <span class="Statement">if</span> i <span class="Statement">=</span> width<span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">generate</span>
            ms_cell : full_adder
                <span class="Statement">port</span> <span class="Statement">map</span> <span class="Special">(</span>a<span class="Special">(</span>i<span class="Special">),</span> b<span class="Special">(</span>i<span class="Special">),</span> c_in<span class="Special">(</span>i<span class="Special">),</span> sum<span class="Special">(</span>i<span class="Special">),</span> carry<span class="Special">);</span>
        <span class="Statement">end</span> <span class="Statement">generate</span> ms_bit<span class="Special">;</span>

    <span class="Statement">end</span> <span class="Statement">generate</span> adder<span class="Special">;</span>

Figure6-2. Generate statement for adder.

The outer generate statement iterates with i taking on values from 0 to width-1. For the least significant bit (i=0), an instance of a half adder component is generated. The input bits are connected to the least significant bits of a and b, the output bit is connected to the least significant bit of sum, and the carry bit is connected to the carry in of the next stage.  For intermediate bits, an instance of a full adder component is generated with inputs and outputs connected similarly to the first stage. For the most significant bit (i=width-1), an instance of the half adder is also generated, but its carry output bit is connected to the signal carry.

<h3>6.4. Concurrent Assertions and Procedure Calls</h3>
There are two kinds of concurrent statement which were not covered in previous chapters: concurrent assertions and concurrent procedure calls.  A concurrent assertion statement is equivalent to a process containing only an assertion statement followed by a wait statement. The syntax is:

<span class="Constant">concurrent_assertion_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> postponed </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">assertion</span><span class="Statement"> ;</span>


The concurrent signal assertion:

    L : <span class="Statement">assert</span> condition <span class="Statement">report</span> error_string <span class="Statement">severity</span> severity_value<span class="Special">;</span>


is equivalent to the process:

    L : <span class="Statement">process</span>
    <span class="Statement">begin</span>
        <span class="Statement">assert</span> condition <span class="Statement">report</span> error_string <span class="Statement">severity</span> severity_value<span class="Special">;</span>
        <span class="Statement">wait</span> [ sensitivity_clause ] <span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">process</span> L<span class="Special">;</span>


The sensitivity clause includes all the signals which are referred to in the condition expression. If no signals are referenced, the process is activated once at simulation initialisation, checks the condition, and then suspends indefinitely.
The other concurrent statement, the concurrent procedure call, is equivalent to a process containing only a procedure call followed by a wait statement. The syntax is:

<span class="Constant">concurrent_procedure_call_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine">label</span><span class="Statement">: </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> postponed </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfLine">procedure_call</span><span class="Statement"> ;</span>


The procedure may not have any formal parameters of class variable, since it is not possible for a variable to be visible at any place where a concurrent statement may be used. The sensitivity list of the wait statement in the process includes all the signals which are actual parameters of mode in or inout in the procedure call. These are the only signals which can be read by the called procedure.
Concurrent procedure calls are useful for defining process behaviour that may be reused in several places or in different models. For example, suppose a package bit_vect_arith declares the procedure:

    <span class="Statement">procedure</span> add<span class="Special">(</span><span class="Statement">signal</span> a<span class="Special">,</span> b : <span class="Statement">in</span> <span class="Type">bit_vector</span><span class="Special">;</span> <span class="Statement">signal</span> result : <span class="Statement">out</span> <span class="Type">bit_vector</span><span class="Special">);</span>


Then an example of a concurrent procedure call using this procedure is:

    adder : bit_vect_arith<span class="Special">.</span>add <span class="Special">(</span>sample<span class="Special">,</span> old_accum<span class="Special">,</span> new_accum<span class="Special">);</span>


This would be equivalent to the process:

    adder : <span class="Statement">process</span>
    <span class="Statement">begin</span>
        bit_vect_arith<span class="Special">.</span>add <span class="Special">(</span>sample<span class="Special">,</span> old_accum<span class="Special">,</span> new_accum<span class="Special">);</span>
        <span class="Statement">wait</span> <span class="Statement">on</span> sample<span class="Special">,</span> old_accum<span class="Special">;</span>
    <span class="Statement">end</span> <span class="Statement">process</span> adder<span class="Special">;</span>


<h3>6.5. Entity Statements</h3>
In Section3.1, it was mentioned that an entity declaration may include statements for monitoring operation of the entity. Recall that the syntax for an entity declaration is:

<span class="Constant">entity_declaration </span><span class="PreProc">::=</span>
<span class="Statement">    entity </span><span class="bnfLine">identifier</span><span class="Statement"> is</span>
<span class="Statement">        </span><span class="bnfLine">entity_header</span>
<span class="Statement">        </span><span class="bnfLine">entity_declarative_part</span>
<span class="Statement">    </span><span class="bnfOr">[</span><span class="Statement"> begin </span><span class="bnfLine">entity_statement_part</span><span class="Statement"> </span><span class="bnfOr">]</span>
<span class="Statement">    end </span><span class="bnfOr">[</span><span class="Statement"> entity </span><span class="bnfOr">]</span><span class="Statement"> </span><span class="bnfOr">[</span><span class="Statement"> </span><span class="bnfLine"><i>entity</i>_simple_name</span><span class="Statement"> </span><span class="bnfOr">]</span><span class="Statement"> ;</span>


The syntax for the statement part is:

<span class="Constant">entity_statement_part </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfOr">{</span><span class="Statement"> </span><span class="bnfLine">entity_statement</span><span class="Statement"> </span><span class="bnfOr">}</span>

<span class="Constant">entity_statement </span><span class="PreProc">::=</span>
<span class="Statement">    </span><span class="bnfLine">concurrent_assertion_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>passive</i>_concurrent_procedure_call_statement</span><span class="Statement"> </span><span class="bnfOr">|</span>
<span class="Statement">    </span><span class="bnfLine"><i>passive</i>_process_statement</span>


The concurrent statement that are allowed in an entity declaration must be passive, that is, they may not contain any signal assignments. (This includes signal assignments inside nested procedures of a process.) A result of this rule is that such processes cannot modify the state of the entity, or any circuit the entity may be used in. However, they can fully monitor the state, and so may be used to report erroneous operating conditions, or to trace the behaviour of the design.
=== End Of Text ===
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
